#!/bin/bash

DSH_VERSION=1.99.56

# Console colors
red='\033[0;91m'
red_bg='\033[101m'
green='\033[0;32m'
green_bg='\033[42m'
yellow='\033[1;33m'
NC='\033[0m'

DRUDE_BRANCH="${DRUDE_BRANCH:-master}"

#---------------------------- Global Constants --------------------------------
DSH_REQUIREMENTS_DOCKER='1.11.2'
DSH_REQUIREMENTS_DOCKER_COMPOSE='1.7.1'
DSH_REQUIREMENTS_DOCKER_MACHINE='0.7.0'
DSH_REQUIREMENTS_VBOX='5.0.4'
DSH_REQUIREMENTS_WINPTY='0.3.1'
DSH_REQUIREMENTS_WINPTY_CYGWIN='2.5.1'

# Configuration paths
DRUDE_CONFIG_DIR="$HOME/.drude"
DRUDE_CONFIG_ALIAS="$DRUDE_CONFIG_DIR/alias"
DRUDE_LAST_CHECK="$DRUDE_CONFIG_DIR/last_check"
DRUDE_MACHINE="$DRUDE_CONFIG_DIR/machines"
DRUDE_MACHINE_ACTIVE="$DRUDE_MACHINE/.active"
# BIN folder
DRUDE_BIN_DIR="$DRUDE_CONFIG_DIR/bin"
DRUDE_DOWNLOADS_DIR="$DRUDE_BIN_DIR/downloads"
DOCKER_BIN="$DRUDE_BIN_DIR/docker"
DOCKER_COMPOSE_BIN="$DRUDE_BIN_DIR/docker-compose"
DOCKER_MACHINE_BIN="$DRUDE_BIN_DIR/docker-machine"
DOCKER_MACHINE_SMB_BIN="$DRUDE_BIN_DIR/docker-machine-smb"
vboxmanage="vboxmanage"
(uname | grep 'CYGWIN_NT' >/dev/null) && \
	vboxmanage="/c/Program Files/Oracle/VirtualBox/VBoxManage.exe"

# Where custom commands live (relative path)
DRUDE_COMMANDS_PATH=".drude/commands"

# Network settings
DRUDE_SUBNET="192.168.10.1/24"
DRUDE_DEFAULT_DNS="8.8.8.8"
DRUDE_VBOX_DNS="10.0.2.3" # TODO: check this

DEFAULT_MACHINE_NAME='drude'
DEFAULT_MACHINE_PROVIDER='virtualbox'
DEFAULT_MACHINE_VBOX_RAM='1024' #mb
DEFAULT_MACHINE_VBOX_HDD='20000' #mb
DEFAULT_MACHINE_DO_SIZE='1gb' # digitalocean default size (512mb, 1gb, 2gb...)

#---------------------------- URL references --------------------------------
OS_NAME=$(uname -s)
HARDWARE=$(uname -m)
URL_DRUDE_REPO="https://raw.githubusercontent.com/blinkreaction/drude"
URL_DRUDE_REPO_UI="https://github.com/blinkreaction/drude"
URL_DSH="${URL_DRUDE_REPO}/${DRUDE_BRANCH}/bin/dsh"

URL_DOCKER_MAC="https://get.docker.com/builds/$OS_NAME/$HARDWARE/docker-${DSH_REQUIREMENTS_DOCKER}.tgz"
URL_DOCKER_NIX="https://get.docker.com/"
URL_DOCKER_WIN="https://get.docker.com/builds/Windows/i386/docker-${DSH_REQUIREMENTS_DOCKER}.zip"
URL_DOCKER_COMPOSE_MAC="https://github.com/docker/compose/releases/download/${DSH_REQUIREMENTS_DOCKER_COMPOSE}/docker-compose-$OS_NAME-$HARDWARE"
URL_DOCKER_COMPOSE_NIX="$URL_DOCKER_COMPOSE_MAC"
URL_DOCKER_COMPOSE_WIN="https://github.com/docker/compose/releases/download/${DSH_REQUIREMENTS_DOCKER_COMPOSE}/docker-compose-Windows-x86_64.exe"
URL_DOCKER_MACHINE_MAC="https://github.com/docker/machine/releases/download/v${DSH_REQUIREMENTS_DOCKER_MACHINE}/docker-machine-$OS_NAME-$HARDWARE"
URL_DOCKER_MACHINE_WIN="https://github.com/docker/machine/releases/download/v${DSH_REQUIREMENTS_DOCKER_MACHINE}/docker-machine-Windows-x86_64.exe"

URL_DOCKER_MACHINE_SMB="https://raw.githubusercontent.com/drude/docker-machine-smb/master/docker-machine-smb"
URL_WINPTY="https://github.com/rprichard/winpty/releases/download/${DSH_REQUIREMENTS_WINPTY}/winpty-${DSH_REQUIREMENTS_WINPTY}-cygwin-${DSH_REQUIREMENTS_WINPTY_CYGWIN}-ia32.tar.gz"

URL_DRUDE_CONFIG="${URL_DRUDE_REPO}/${DRUDE_BRANCH}/docker-compose.yml"
URL_BASH_AUTOCOMPLETE="${URL_DRUDE_REPO}/${DRUDE_BRANCH}/bin/dsh-bash-complete"

IMAGE_SSH_AGENT="blinkreaction/ssh-agent"
IMAGE_VHOST_PROXY="blinkreaction/nginx-proxy"
IMAGE_DNS="blinkreaction/dns-discovery"

#---------------------------- Global Variables --------------------------------

PATH="$DRUDE_BIN_DIR:$PATH"
DOCKER_BETA="${DOCKER_BETA:-0}"
# Allow image tag overrides for system services. See install_xyz_service()
DRUDE_ITAG="${DRUDE_ITAG:-stable}"
# UID of user to use in cli continer. Only override if you know what you're doing
DRUDE_SET_UID=""

__drude_active_machine=$(cat "$DRUDE_MACHINE_ACTIVE" 2>/dev/null)
DOCKER_MACHINE_NAME="${__drude_active_machine:-$DEFAULT_MACHINE_NAME}"
DOCKER_MACHINE_STATUS="$(docker-machine status "$DOCKER_MACHINE_NAME" 2>&1)"
[[ "$DOCKER_MACHINE_STATUS" ==  'Running' ]] && \
	eval $(docker-machine env --shell=bash "$DOCKER_MACHINE_NAME")

#---------------------------- Helper functions --------------------------------

DRUDE_YML_PATH='' #yml path value will be cached here
DRUDE_PATH='' #drude path value will be cached here
IS_LINUX='' # is_linux cache

echo-red () { echo -e "${red}$1${NC}"; }
echo-green () { echo -e "${green}$1${NC}"; }
echo-green-bg () { echo -e "${green_bg}$1${NC}"; }
echo-yellow () { echo -e "${yellow}$1${NC}"; }
echo-error () {
	echo -e "${red_bg} DSH ERROR: ${NC} ${red}$1${NC}";
	local unused="$2" # avoid IDE warning
	shift
	# echo other parameters indented s error description or remedy
	while [[ "$1" != "" ]]; do
		echo -e "             $1";
		shift
	done
}

# Exits dsh if previous command exited with non-zero code
if_failed ()
{
	if [ ! $? -eq 0 ]; then
		msg="error executing last command"
		if [[ "$1" != "" ]]; then msg="$1"; fi
		echo-red "dsh: $msg"
		exit 1
	fi
}
# Like if_failed but with more strict error
if_failed_error ()
{
	if [ ! $? -eq 0 ]; then
		msg="error executing last command"
		if [[ "$1" != "" ]]; then msg="$1"; fi
		echo-error "$msg"
		exit 1
	fi
}

# Search for a file/directory in a directiry tree upwards. Return it's path.
# @param $1 filename
upfind ()
{
	if [[ $1 == '' ]]; then return 1; fi
	( #incapsulate cd
		while [[ ! -f $1 ]] && [[ ! -d $1 ]] && [[ $PWD != / ]]; do
			cd ".."
		done;
		if [[ -f $1 ]] || [[ -d $1 ]]; then echo $PWD; exit; fi
	)
}

# Get path to docker-compose.yml using upfind
get_yml_path ()
{
	if [ -z "$DRUDE_YML_PATH" ]; then
		DRUDE_YML_PATH=$(upfind "docker-compose.yml")
	fi
	echo "$DRUDE_YML_PATH"
}

# Get path to .drude folder using upfind
get_drude_path ()
{
	if [ -z "$DRUDE_PATH" ]; then
		DRUDE_PATH=$(upfind ".drude")
	fi
	echo "$DRUDE_PATH"
}

# Returns absolute path
# @param $1 file/dir relative path
get_abs_path ()
{
	local _dir
	if [[ -f "$1" ]]; then
		_dir="$(dirname $1)"
	elif [[ -d "$1" ]]; then
		_dir="$1"
	else
		echo "Path \"$1\" does not exist"
		return 1
	fi
	echo "$(cd "${_dir}" ; pwd)"
}

# Return current path relative to project root with trailing slash
get_current_relative_path ()
{
	# Check that we're inside project folder
	local proj_root=$(get_yml_path)
	local cwd=$(pwd)
	# if cwd substract proj_root is still cwd then it means we're out of proj_root (unsubstractable)
	# ex: cwd=/a/b/c/d, proj_root=/a/b/c, pathdiff==d
	# ex: cwd=/a/b, proj_root=/a/b/c, pathdiff==/a/b
	local pathdiff=${cwd#${proj_root}/}
	echo "$pathdiff"
}

# Get mysql connection string
get_mysql_connect ()
{
	# Run drush forcing tty to false to avoid colored output string from drush.
	echo "$(_run drush sql-connect)"
}

# Use this function for every docker-compose invocation.
docker_compose ()
{
	# docker-compose cannot find docker-compose.yml in the path if there are symlinks on the way
	# get_yml_path can properly find the file. Incapsulate the cd into subshell
	(cd "$(get_yml_path)" && "$DOCKER_COMPOSE_BIN" "$@")
}

# Get container id by service name
# @param $1 docker compose service name (e.g. cli)
# @return docker container id 
get_container_id ()
{
	# Trim CR(\r) from the output, otherwise there will be issues passing it to the docker binary on Windows.
	echo $(docker_compose ps -q $1 2>/dev/null | tr -d '\r')
}

# Run command on Windows with elevated privileges
winsudo ()
{
	cygstart --action=runas cmd /c "$@"
}

# Universal Bash parameter parsing
# Parse equals separated params into named local variables
# Standalone named parameter value will equal param name (--force creates variable $force=="force")
# Parses multi-valued named params into array (--path=path1 --path=path2 creates ${path[*]} array)
# Parses un-named params into ${ARGV[*]} array
# @author Oleksii Chekulaiev
# @version v1.1 (Jul-14-2016)
parse_params ()
{
	local existing_named
	local ARGV=()
	echo "local ARGV=(); "
	while [[ "$1" != "" ]]; do
		# If equals delimited named parameter
		if [[ "$1" =~ ^..*=..* ]]; then
			# key is part before first =
			local _key=$(echo "$1" | cut -d = -f 1)
			# val is everything after key and = (protect from param==value error)
			local _val=${1/$_key=}
			# remove dashes from key name
			_key=${_key//\-}
			# search for existing parameter name
			if (echo "$existing_named" | grep "\b$_key\b" >/dev/null); then
				# if name already exists then it's a multi-value named parameter
				# re-declare it as an array if needed
				if ! (declare -p _key 2> /dev/null | grep -q 'declare \-a'); then
					echo "$_key=(\"\$$_key\");"
				fi
				# append new value
				echo "$_key+=('$_val');"
			else
				# single-value named parameter
				echo "local $_key=\"$_val\";"
				existing_named=" $_key"
			fi
		# If standalone named parameter
		elif [[ "$1" =~ ^\-. ]]; then
			# remove dashes
			local _key=${1//\-}
			echo "local $_key=\"$_key\";"
		# non-named parameter
		else
			echo "ARGV+=('$1');"
		fi
		shift
	done
}

#------------------------- Basics check functions -----------------------------

is_linux ()
{
	[[ $IS_LINUX == "true" ]] && return 0
	uname | grep 'Linux' >/dev/null
}

is_ubuntu ()
{
	if [ -r /etc/lsb-release ]; then
		lsb_dist="$(. /etc/lsb-release && echo "$DISTRIB_ID")"
		lsb_release="$(. /etc/lsb-release && echo "$DISTRIB_RELEASE")"
	fi

	if [[ "$lsb_dist" != 'Ubuntu' || $(ver_to_int "$lsb_release") < $(ver_to_int '14.04') ]]; then
		return 1
	fi

	return 0
}

is_windows ()
{
	uname | grep 'CYGWIN_NT' >/dev/null
}

is_mac ()
{
	uname | grep 'Darwin' >/dev/null
}

is_docker_beta ()
{
	# comparison returns error codes
	[[ "$DOCKER_BETA" == "1" ]]
}

# searches if binary exists and callable in PATH
is_binary_found ()
{
	if [[ "$1" == "" ]]; then
		return 1;
	fi

	local bpath=$(which $1 2>/dev/null)

	if [[ "$bpath" != "" ]] && [ -f $(which $1) ]; then
		return 0
	else
		return 1
	fi
}

# checks if binary exists and fails is it isn't
check_binary_found ()
{
	[[ -x "$DRUDE_BIN_DIR/$1" ]]
	if_failed "$1 executable was not found in $DRUDE_BIN_DIR. (Try running 'dsh install prerequisites')"
}

is_docker_running ()
{
	if ! is_linux; then
		if ! is_docker_machine_running; then return 255; fi
	fi
	# Check if docker is running via docker info.
	# This operation is instant even if docker is not running (assuming a socket is used).
	docker info >/dev/null
}

# Check whether shell is interactive
# Otherwise we are running in a non-interactive script environment
is_tty ()
{
	[[ "$(/usr/bin/tty || true)" != "not a tty" ]]
}

#---------------------------- Other helper functions -------------------------------

testing_warn ()
{
	[[ "$DRUDE_BRANCH" != 'master' ]] && is_tty && \
		echo-yellow "drude - ${DRUDE_BRANCH} branch"
}

# Convert version string like 1.2.3 to integer for comparison
# param $1 version string of 3 components max (e.g. 1.10.3)
ver_to_int ()
{
	printf "%03d%03d%03d" $(echo "$1" | tr '.' ' ')
}

#---------------------------- Control functions -------------------------------

check_dsh_environment ()
{
	check_yml && check_docker_running
}

check_docker_running ()
{
	# Check cached value
	[[ "$DOCKER_RUNNING" == "true" ]] && return 0
	local docker_status

	check_binary_found 'docker'
	check_binary_found 'docker-compose'
	if ! is_docker_version; then
		echo-error "Required Docker version is $DSH_REQUIREMENTS_DOCKER or higher"
		echo -e "Run ${yellow}dsh update prerequisites${NC} to update"
		exit 1
	fi

	is_docker_running
	docker_status=$?

	if [[ $docker_status -eq 255 ]]; then
		echo-yellow "It looks like '$DOCKER_MACHINE_NAME' docker machine is not running."
		_confirm "Run 'dsh vm start' to start it now?"
		vm start
		if_failed "Could not start Drude docker machine properly"
		# re-check status
		docker info >/dev/null
		docker_status=$?
	fi

	if [[ $docker_status -eq 0 ]]; then
		DOCKER_RUNNING="true"
	else
		echo-error "Looks like your Docker client and Docker server are incompatible." \
			"Run ${yellow}dsh install prerequisites${NC} to update."
		exit 1
	fi
}

is_vbox_version ()
{
	if is_windows; then
		[[ ! -f "$vboxmanage" ]] && return 1
	else
		! is_binary_found "$vboxmanage" && return 1
	fi

	local virtualbox_version=$("$vboxmanage" -v | sed "s/r.*//" 2>/dev/null)
	[[ $(ver_to_int "$virtualbox_version") < $(ver_to_int "$DSH_REQUIREMENTS_VBOX") ]] && \
		return 2

	return 0
}

is_docker_version ()
{
	[[ ! -x "$DOCKER_BIN" ]] && return 1

	local version=$(docker -v | sed "s/^Docker version \(.*\),.*/\1/")
	[[ "$version" == "$DSH_REQUIREMENTS_DOCKER" ]] && \
		return 0;

	return 1;
}

is_docker_compose_version ()
{
	[[ ! -x "$DOCKER_COMPOSE_BIN" ]] && return 1

	local version=$(docker_compose -v | sed "s/^docker-compose version \(.*\),.*/\1/")
	[[ "$version" == "$DSH_REQUIREMENTS_DOCKER_COMPOSE" ]] && \
		return 0;

	return 1;
}

is_docker_machine_version ()
{
	[[ ! -x "$DOCKER_MACHINE_BIN" ]] && return 1

	local version=$(docker-machine -v | sed "s/^docker-machine version \(.*\),.*/\1/")
	[[ "$version" == "$DSH_REQUIREMENTS_DOCKER_MACHINE" ]] && \
		return 0;

	return 1;
}

check_vbox_version ()
{
	is_vbox_version
	local res=$?
	[[ $res == 1 ]] && echo-error "$vboxmanage binary was not found" && exit 1
	[[ $res == 2 ]] && echo-error "VirtualBox version should be $DSH_REQUIREMENTS_VBOX or higher" && exit 1
}

# Check that docker-compose.yml is present
check_yml ()
{
	yml_path=$(get_yml_path)
	if [[ "$yml_path" == "" ]] ; then
		echo-red "dsh: docker-compose.yml was not found in your directory tree"
		exit 1
	fi
}

# Check that command is run inside project folder
check_drush_path ()
{
	local pathdiff=$(get_current_relative_path)
	if [[ "$(pwd)" == "$pathdiff" ]]; then
		echo-red "dsh: This command must be run inside Drupal's document root"
		exit 1
	fi
}

# Yes/no confirmation dialog with an optional message
# @param $1 confirmation message
_confirm ()
{
	# Skip checks if not running interactively (not a tty or not on Windows)
	if ! is_tty; then return 0; fi

	while true; do
		read -p "$1 [y/n]: " answer
		case "$answer" in
			[Yy]|[Yy][Ee][Ss] )
				break
				;;
			[Nn]|[Nn][Oo] )
				exit 1
				;;
			* )
				echo 'Please answer yes or no.'
		esac
	done
}

# Display desktop notification (Mac only)
# @param $1 title
# @param $2 message
_notify ()
{
	if is_mac && [[ "$1" != "" ]]; then
		osascript -e 'display notification "'"$2"'" with title "'"$1"'"'
	fi
}

#-------------------------- Containers management -----------------------------

_start_containers ()
{
	check_docker_running
	ssh_add
	echo-green "Starting services..."
	docker_compose up -d && \
		_vhost_proxy_connect && \
		_set_cli_uid
}

# @param $1 container_name
_restart_containers ()
{
	check_docker_running
	echo-green "Restarting services..."
	docker_compose restart "$@" && \
		_vhost_proxy_connect && \
		_set_cli_uid
}

# @param $1 "-a" || "--all"
_stop_containers ()
{
	if [[ $1 == '-a' ]] || [[ $1 == '--all' ]]; then
		check_docker_running
		echo-green "Stopping all running services from all projects..."
		# stop all but system containers (--label "group=system")
		docker ps --format '{{.Names}} {{.Label "group"}}' | grep -v 'system' | xargs docker stop
		return
	fi

	if [[ "$1" == "proxy" ]] ; then
		echo-green 'Stopping Drude HTTP/HTTPS reverse proxy service...'
		docker stop vhost-proxy >/dev/null
		return
	fi

	if [[ "$1" == "dns" ]] ; then
		echo-green 'Stopping Drude DNS service...'
		docker stop dns >/dev/null
		return
	fi

	if [[ "$1" == "ssh-agent" ]] ; then
		echo-green 'Stopping Drude ssh-agent service...'
		docker stop ssh-agent >/dev/null
		return
	fi

	check_dsh_environment
	echo-green "Stopping services..."
	docker_compose stop
}

# @param $1 container_name
_remove_containers ()
{
	check_dsh_environment
	if [[ $1 == "" ]]; then
		echo-yellow "Removing containers..."
	fi
	docker_compose kill "$@" && docker_compose rm -vaf "$@"
}

# Cleanup unused images and containters
# @param $1 --hard if set removes all stopped containers
_docker_cleanup ()
{
	check_docker_running
	if [[ "$1" == "--hard" ]] && [[ "$(docker ps -aqf status=exited)" != "" ]]; then
		echo -e "${red}WARNING: ${yellow}Preparing to delete all currently stopped containers:${NC}"
		docker ps -af status=exited --format "{{.Label \"com.docker.compose.project\"}}_{{.Label \"com.docker.compose.service\"}}\t\t{{.Status}} ({{.Image}})"
		printf 'â€“%.0s' $(seq 1 40)
		echo -e "${yellow}"
		_confirm "Continue?"
		echo -e "${NC}"
		#--
		echo-green "Removing stopped containers..."
		docker ps -aqf status=exited | xargs docker rm -vf
	fi

	echo-green "Cleaning up images..."
	docker images -qf dangling=true | xargs docker rmi 2>1
	# TODO: remove below lines in 2017
	rm -f "$DRUDE_CONFIG_DIR/Vagrantfile."* 2>/dev/null 1>/dev/null
	rm -f "$DRUDE_CONFIG_DIR/backups/Vagrantfile."* 2>/dev/null 1>/dev/null
	rm -r "$DRUDE_CONFIG_DIR/backups" 2>/dev/null 1>/dev/null
	rm -f "$DRUDE_CONFIG_DIR/vagrant.yml."* 2>/dev/null 1>/dev/null
	rm -f "$DRUDE_CONFIG_DIR/backups/vagrant.yml."* 2>/dev/null 1>/dev/null
	rm -f "$DRUDE_CONFIG_DIR/b2d_version" 2>/dev/null 1>/dev/null
}

# Connect vhost-proxy to all bridge networks on the host
_vhost_proxy_connect ()
{
	echo-green "Connecting vhost-proxy to networks..."
	docker network ls -q --filter name=_default | while read network; do
		docker network connect "$network" vhost-proxy >/dev/null 2>&1 || true
	done
}

#------------------------------ Help functions --------------------------------

# Nicely prints command help
# @param $1 command name
# @param $2 description
# @param $3 [optional] command color
printh ()
{
	local COMMAND_COLUMN_WIDTH=30;
	case "$3" in
		yellow)
			printf "\t${yellow}%-${COMMAND_COLUMN_WIDTH}s${NC}" "$1"
			;;
		green)
			printf "\t${green}%-${COMMAND_COLUMN_WIDTH}s${NC}" "$1"
			;;
		*)
			printf "\t%-${COMMAND_COLUMN_WIDTH}s" "$1"
			;;
	esac
	echo -e "	$2"
}

# Show help for dsh or for certain command
# $1 name of command to show help for
show_help ()
{
	local project_commands_path="$(get_drude_path)/$DRUDE_COMMANDS_PATH"
	local global_commands_path="$HOME/$DRUDE_COMMANDS_PATH"
	local custom_commands_list

	# If nonempty param then show help for a certain command
	if [[ ! -z "$1" ]]; then
		# Check for help function for specific command
		type "show_help_$1" 1>/dev/null 2>/dev/null
		if [ $? -eq 0 ]; then
			show_help_$1
			exit
		fi
		# Check for custom command file
		# Try global command
		local _command="$global_commands_path/$1"
		# But if local command exists then override
		[ -f "$project_commands_path/$1" ] && _command="$project_commands_path/$1"
		#
		if [ -f "$_command" ]; then
			echo -en "${green}dsh $1${NC} - "
			cat "$_command" | grep '^##' | sed "s/^##[ ]*//g"
			echo
			exit
		fi
	fi

	printh "Drude Shell v$DSH_VERSION commands reference" "" "green"
	echo
	if is_linux; then
		printh "start (up)" "Start project services"
	else
		printh "start (up)" "Start docker machine and project services"
	fi
	printh "stop (down) [-a (--all)]" "Stop project services. -a stops all containers except Drude system services"
	printh "restart	[service]" "Restart all current project services or specified service"
	printh "status (st, ps) [-a (--all)]" "Show project services status. -a shows all running containers"
	printh "reset [service]" "Recreate service(s). If no parameter given recreates all project services."
	printh "" "See ${yellow}'dsh help reset'${NC} for more details on resetting Drude system services."
	printh "remove [service]" "Remove project or system services. See ${yellow}'dsh help remove'${NC}"
	! is_linux && \
		printh "vm <command>" "Control docker machine vm. See ${yellow}'dsh help vm'${NC} for commands list" "yellow"
	echo
	printh "bash [service]" "Open bash to service container. Defaults to ${yellow}'cli'${NC} service"
	printh "exec <command> [params]" "Execute a command in ${yellow}'cli'${NC} service container"
	printh "exec-url <url>" "Download script from URL and run it. URL should be public."
	printh "logs [service]" "Show docker logs for service container"
	echo
	printh "drush [command] [options...]" "Execute Drush command"
	printh "drupal [command]" "Execute Drupal Console command (Drupal 8)"
	echo
	printh "mysql (sqlc)" "Opens mysql shell to current project database"
	printh "mysql-import (sqli) <file>" "Truncate database and import from sql dump (file should be accessible to Drude)"
	printh "" "See ${yellow}dsh help sqli${NC} for advanced usage (multisite, gz)."
	printh "behat [--path=path]" "Run Behat tests from path relative to YML path. Default: tests/behat"
	echo
	printh "ssh-add [-lD] [key]" "Adds private key identities to the authentication agent. See ${yellow}'dsh help ssh-add'${NC}"

	echo
	printh "install <component>" "<prerequisites | drude-config | autocomplete> (${yellow}'dsh help install'${NC})" "yellow"
	printh "update  <component>" "<prerequisites | images | dsh> (${yellow}'dsh help update'${NC})" "yellow"

	echo
	printh "alias" "Create/delete aliases (See ${yellow}'dsh help alias'${NC})"
	printh "cleanup [--hard]" "Remove unused docker images (--hard will also remove stopped containers)"
	printh "sysinfo" "Show diagnostics information for bug reporting"
	printh "version	(v, -v)" "Print dsh version. [v, -v] - prints short version"

	# Show list of custom commands and their help if available
	if [ ! -z "$(get_drude_path)" ]; then
		show_help_list_of_custom_commands 'project'
	fi
	if [ ! -z "$HOME/$DRUDE_COMMANDS_PATH" ]; then
		show_help_list_of_custom_commands 'global'
	fi

	echo
}

# param $1 - 'project' or 'global'
show_help_list_of_custom_commands ()
{
	local _path
	if [[ "$1" == 'project' ]]; then
		_path="$(get_drude_path)/$DRUDE_COMMANDS_PATH"
		# avoid taking global .drude folder for project one
		if [[ "$_path" == "$HOME/$DRUDE_COMMANDS_PATH" ]]; then return; fi
	else
		_path="$HOME/$DRUDE_COMMANDS_PATH"
	fi

	custom_commands_list=$(ls "$_path" 2>/dev/null | tr "\n" " ")
	if [ ! -z "$custom_commands_list" ]; then
		echo
		echo -e "Custom commands found in ${yellow}$1 commands${NC}:";
		for cmd_name in $(ls "$_path")
		do
			# command description is lines that start with ##
			local cmd_desc=$(cat "$_path/$cmd_name" | grep '^##' | sed "s/^##[ ]*//g" | head -1 --)
			printh "$cmd_name" "$cmd_desc"
		done
	fi
}

show_help_ssh-add ()
{
	echo-green "dsh ssh-add - Add private key identities to the ssh-agent."
	echo "Usage: dsh ssh-add [-lD] [key]"
	echo
	echo "When run without arguments, picks up the default key file (~/.ssh/id_rsa or ~/.ssh/id_dsa)."
	echo "A custom key name can be given as an argument: dsh ssh-add <keyname>."
	echo 
	echo -e "${yellow}NOTE${NC}: <keyname> is the file name within ${yellow}~/.ssh${NC} (not full path to file)."
	echo "Example: dsh ssh-add my_custom_key_rsa"
	echo
	echo "The options are as follows:"
	printh "-D" "Deletes all identities from the agent."
	printh "-l" "Lists fingerprints of all identities currently represented by the agent."
	echo
}

show_help_exec ()
{
	echo-green "dsh exec <command> - Execute command in ${yellow}cli${green} service container."
	echo
	echo "Command is a required parameter."
	echo "Command will be executed in the path that matches your local current path."
	echo
	echo-green "Examples:"
	printh "dsh exec pwd" "Show current path"
	printh "dsh exec ls -la" "Current directory listing"
	printh "dsh exec compass compile" "Compile SASS/SCSS"
	printh "dsh exec \"ls -la > /tmp/list\"" "Execute advanced shell command with pipes or redirects inside cli"
	echo
}

show_help_reset ()
{
	echo-green "dsh reset - Recreate services/containers. Equal to dsh stop, dsh remove, dsh start"
	echo
	echo-green "Parameters: one or more service names. Examples:"
	echo "	dsh reset web		Restart 'web' service"
	echo "	dsh reset web cli	Restart 'web' and 'cli' services"
	echo "	dsh reset		Restart all project services"
	echo
	echo-green "System services"
	echo -e "Drude has 3 system services."
	echo -e "Names ${yellow}'dns'${NC}, ${yellow}'proxy'${NC}, ${yellow}'ssh-agent'${NC} and ${yellow}'system'${NC} are reserved and are not recommended for use."
	echo "	dsh reset dns		Recreate Drude DNS service"
	echo -e "	dsh reset proxy		Recreate Drude HTTP/HTTPS reverse proxy service (resolves ${yellow}*.drude${NC} domain names into container IPs)"
	echo "	dsh reset ssh-agent	Recreate Drude ssh-agent service"
	echo "	dsh reset system	Recreate all Drude system services"
	echo
}

show_help_remove ()
{
	echo-green "dsh remove - Remove services/containers"
	echo
	echo -e "${green}Parameters:${NC} one or more service names."
	echo-green "Examples:"
	printh "dsh remove web" "Remove web service"
	printh "dsh remove proxy" "Stop Drude reverse proxy service"
	echo
}

show_help_install ()
{
	echo-green "dsh install - Automated install of Drude system components"
	echo
	printh "dsh install prerequisites" "Install software required to run Drude"
	printh "dsh install drude-config" "Download latest default docker-compose.yml"
	printh "dsh install autocomplete" "Install dsh commands autocomplete for Bash"
	echo
}

show_help_update ()
{
	echo-green "dsh update - Automated update of Drude system components"
	echo
	printh "dsh update prerequisites" "Update software required to run Drude"
	printh "dsh update images" "Update container images <https://docs.docker.com/engine/understanding-docker/#what-is-docker-s-architecture>"
	printh "dsh update dsh" "Update dsh itself (Used to be named: dsh self-update)"
	echo
}

show_help_exec-url ()
{
	echo-green "dsh exec-url <url> - Fetch script and evaluate locally"
	echo
	echo -e "URL is required parameter. Useful for demos or installations."
	echo
}


show_help_sqli ()
{
	echo-green "dsh sqli <db_dump_file> - Import DB dump into database truncating it first"
	echo
	echo -e "DB dump file can be either plain ${yellow}.sql${NC} file or gzipped ${yellow}.sql.gz${NC}."
	echo -e "To import dump into sub-site cd into sub-site folder ${yellow}cd docroot/sites/sub-site${NC} and run dsh sqli from there."
	echo
	echo-green "Examples:"
	printh "dsh sqli ../../mydump.sql" "Import plaintext sql dump"
	printh "dsh sqli otherdump.sql.gz" "Import gzipped sql dump"
	echo
}

show_help_vm ()
{
	echo-green "dsh vm <command> - Control docker machine directly"
	echo
	echo-green "Commands:"
	printh "start" "Start a machine"
	printh "restart" "Restart a machine"
	printh "status" "Get the status of a machine"
	printh "stop" "Stop a machine"
	printh "ssh" "Log into or run a command on a machine with SSH"
	printh "stats" "Show current HDD/RAM usage stats"
	printh "kill" "Forcibely stop a machine"
	printh "rm" "Remove a machine"
	printh "ip" "Get the IP address of a machine"
	printh "env" "Display the commands to set up the shell for direct use of Docker client"
	echo
	printh "ram" "Display machine's memory size"
	printh "ram [megabytes]" "Set machine's memory size. Default is 1024 (requires vm restart)"
	echo
}

show_help_alias ()
{
	echo-green "dsh alias - Create/delete dsh aliases"
	echo
	echo "Aliases provide functionality similar to drush aliases."
	echo "Using alias you are able to execute dsh command for a project without navigating to the project folder."
	echo "You can precede any command with alias."
	echo
	echo-green "Usage:"
	printh "dsh alias" "Show aliases list"
	printh "dsh alias list" "Show aliases list"
	printh "dsh alias <path> <alias_name>" "Create an alias that links to path"
	printh "dsh alias delete <alias_name>" "Delete alias"
	echo-green "Examples:"
	printh "dsh alias ~/Projects/Site dev" "Create alias named 'dev' that links to '~/Projects/Site'"
	printh "dsh @dev drush st" "Execute 'dsh drush st' command in directory linked by 'dev' alias"
	printh "" "Hint: link alias to sub-site folder to work with that sub-site directly"
	printh "dsh delete dev"	"Delete 'dev' alias"
	echo
	echo "Aliases are effectively symlinks stored in $DRUDE_CONFIG_ALIAS"
}

# Display dsh version
# @option --short - Display only the version number
version ()
{
	if [[ $1 == '--short' ]]; then
		echo "$DSH_VERSION"
	else
		echo "dsh version: $DSH_VERSION"
	fi
}

# return bash completion words
# @param $1 command to return words for
bash_comp_words ()
{
	case $1 in
		install)
			echo "prerequisites drude-config"
			exit 0
			;;
		update)
			echo "prerequisites images dsh"
			exit 0
			;;
		vm)
			echo "start restart status stop ssh stats kill rm ip env ram"
			exit 0
			;;
		alias)
			echo "list remove"
			exit 0
		;;
		dsh)
			local aliases=$(ls -l "$DRUDE_CONFIG_ALIAS" 2>/dev/null | grep -v total | awk '{printf "@%s ", $9}')
			echo "start up stop down restart status reset remove bash exec logs run mysql mysql-import exec-url drush drupal \
			behat ssh-add install update self-update version cleanup vm sysinfo alias $aliases"
			exit 0
			;;
		*)
			exit 1 #return 1 to completion function to prevent completion if we don't know what to do
	esac
}

#------------------------------- Docker-Machine -----------------------------------

is_docker_machine_running ()
{
#	check_binary_found 'docker-machine'
#	docker-machine status "$DOCKER_MACHINE_NAME" 2>/dev/null | grep "Running" 2>&1 1>/dev/null
	[[ "$DOCKER_MACHINE_STATUS" == 'Running' ]]
}

# Create docker machine
# param $1 machine name
# param $2 provider (virtualbox | digitalocean). Defaults to virtualbox
docker_machine_create ()
{
	check_binary_found 'docker-machine'

	local machine_name="${1:-$DEFAULT_MACHINE_NAME}"
	local provider="${2:-$DEFAULT_MACHINE_PROVIDER}"

	if is_docker_machine_exist "$machine_name"; then
		echo-error "Docker Machine '$machine_name' already exists"
		return 1
	fi

	echo-green "Creating docker machine '$machine_name' ($provider)..."
	case "$provider" in
		virtualbox)
			check_vbox_version

			docker-machine create --driver=virtualbox \
				--virtualbox-disk-size "$DEFAULT_MACHINE_VBOX_HDD" \
				--virtualbox-memory "$DEFAULT_MACHINE_VBOX_RAM" \
				--virtualbox-no-share \
				"$machine_name"
			;; #-- end virtualbox

		digitalocean)
			[[ ! "$machine_name" =~ ^[0-9a-zA-Z.-]*$ ]] && echo "Invalid hostname specified. Allowed hostname chars are: 0-9a-zA-Z . -" && return 1
			local token
			echo -n "Provide Digital Ocean access token: "
			read token
			[[ "$token" == "" ]] && echo "Invalid token" && return 1
			# TODO: sync folder on windows is not $HOME
			local syncthing_id
			docker-machine create --driver=digitalocean \
				--digitalocean-access-token="$token" \
				--digitalocean-size="$DEFAULT_MACHINE_DO_SIZE" \
				"$machine_name" &&
				# Set up env variables
				eval $(docker-machine env --shell=bash "$machine_name")
			if_failed "New docker machine creation has failed"

			# Install syncthing container
			echo "Installing Syncthing container..."
			docker run -d --restart=always \
				-v "$HOME":"/srv/data" \
				-v /root/.drude/syncthing:/srv/config \
				-p 22000:22000  -p 21025:21025/udp -p 8080:8080 \
				--name drude-syncthing \
				joeybaker/syncthing &&
			# Wait 10 seconds for syncthing to start
			echo "Waiting for syncthing container to start..." &&
			sleep 10 &&
			# Get Syncthing ID
			syncthing_id=$(docker-machine ssh "$machine_name" 'cat /root/.drude/syncthing/config.xml | grep introducer' | cut -d \" -f 2) &&
			echo-green "($machine_name) Syncthing ID: $syncthing_id"
			echo-green "($machine_name) Syncthing UI: http://$(docker-machine ip ${machine_name}):8080"
			echo "Use Syncthing ID above to add device and share folders."
			# add device automatically
			# [ ! -f "$HOME/Library/Application Support/Syncthing/config.xml" ] && echo "Use Syncthing ID above to pair." && return
			# local apikey=$(grep apikey "$HOME/Library/Application Support/Syncthing/config.xml" | sed "s/<\/*apikey>//g" | tr -d " ")
			;; #-- end digitalocean

		*)
			echo-error "$provider provider is not supported" && (exit 1)
			;;
	esac

	if [[ $? -eq 0 ]]; then
		DOCKER_MACHINE_NAME="$machine_name"
		DOCKER_MACHINE_STATUS='Running'
		vm active "$machine_name"
	else
		return 1
	fi
}

# param $1 machine name (defaults to $DOCKER_MACHINE_NAME)
is_docker_machine_exist ()
{
	if [[ "$1" != "" ]]; then
		docker-machine ls | grep "$1" 1>/dev/null 2>/dev/null
	else
		[[ "$DOCKER_MACHINE_STATUS" == *"not exist"* ]] && return 1 || return 0
	fi
}

# Return docker machine provider
docker_machine_provider ()
{
	docker-machine ls | grep "$DOCKER_MACHINE_NAME" | awk '{print $3}' 2>/dev/null
}

docker_machine_env ()
{
	eval $(docker-machine env --shell=bash "$DOCKER_MACHINE_NAME")
}

# Stop docker machine
docker_machine_stop ()
{
	check_binary_found 'docker-machine'
	docker-machine stop "$DOCKER_MACHINE_NAME"
}

docker_machine_start ()
{
	check_binary_found 'docker-machine'
	is_windows && check_binary_found 'docker-machine-smb'

	if is_docker_machine_exist; then
		docker-machine start "$DOCKER_MACHINE_NAME" && DOCKER_MACHINE_STATUS='Running' && \
			docker_machine_env && \
			reset system && \
			docker_machine_mounts
	else
		if [[ "$DOCKER_MACHINE_NAME" != "$DEFAULT_MACHINE_NAME" ]]; then
			echo-error "Machine '$DOCKER_MACHINE_NAME' does not exist"
			echo-yellow "Removing reference to non-existent machine... Run your command again."
			rm -f "$DRUDE_MACHINE_ACTIVE"
			exit 1
		fi
		# only auto-create default machine
		docker_machine_create && \
			docker_machine_env && \
			reset system && \
			docker_machine_mounts
	fi
}

# Mount folder inside docker-machine by NFS
# Unnamed params - shares in format "$LOCAL_FOLDER:$MOUNT_POINT_NAME"
# Named --no-export param(s) - will try to mount those mount points without exporting $LOCAL_FOLDER
docker_machine_mount_nfs ()
{
	local machine_name="$DOCKER_MACHINE_NAME"
	local network_name
	local nfs_ip
	eval $(parse_params "$@")

	# Get required IP addresses
	network_name=$(VBoxManage showvminfo "$machine_name" --machinereadable | grep hostonlyadapter | cut -d \" -f2)
	if [[ "$network_name" == "" ]]; then
		echo-error "Could not find virtualbox net name." && exit 1
	fi
	# nfs_ip is an internal IP of localhost as docker machine sees it.
	nfs_ip=$(VBoxManage list hostonlyifs | grep "$network_name" -A 3 | grep IPAddress | cut -d ':' -f2 | xargs)
	if [[ "$nfs_ip" == "" ]]; then
		echo-error "Could not find virtualbox internal net IP address." && exit 1
	fi
	machine_ip=$(docker-machine ip "$machine_name")

	# Remove our own old exports
	local exports_open="# <dsh-nfs $machine_name"
	local exports_close="# dsh-nfs>"
	local exports=$(cat /etc/exports | \
		tr "\n" "\r" | \
		sed "s/${exports_open}.*${exports_close}//" | \
		tr "\r" "\n"
	)

	# Prepare new exports file
	exports="${exports}\n${exports_open}\n"
	for share in ${ARGV[@]}; do
		local share_export=(${share//:/ });
		exports="${exports}$share_export $machine_ip -alldirs -mapall=$(id -u):$(id -g)\n"
	done
	exports="${exports}${exports_close}"

	local new_exports=$(echo -e "$exports")
	local old_exports=$(cat /etc/exports)
	if [[ "$new_exports" != "$old_exports" ]]; then
		# Write temporary exports file to /tmp/etc.exports.XXXXX and check it
		local exports_test="/tmp/etc.exports.$RANDOM"
		echo -e "$exports" | tee "$exports_test" >/dev/null
		exports_errors=$(nfsd -F "$exports_test" checkexports 2>&1)
		rm -f "$exports_test" 2>/dev/null 1>/dev/null

		# Do not write /etc/exports if there are config check errors
		if [[ "$exports_errors" != '' ]]; then
			echo-error "$exports_errors"
			echo "-----------------"
			echo -e "$exports"
			echo "-----------------"
			return 1
		fi

		echo-green "Writing /etc/exports..."
		echo -e "$exports" | sudo tee /etc/exports >/dev/null
		echo-green "Restarting nfsd..."
		sudo nfsd restart
		sleep 2
	fi

	# Mount exported folders
	echo-green "Mounting NFS shares..."
	for share in ${ARGV[@]}; do
		local share_=(${share//:/ });
		local share_export="${share_[0]}"
		local share_mount="${share_[1]}"
		# Add new exports
		echo "Mounting local $share_export to $share_mount..."
		docker-machine ssh "$machine_name" \
			"sudo mkdir -p $share_mount ;
			sudo umount $share_mount 2>/dev/null ;
			sudo mount -t nfs -o noacl,async $nfs_ip:$share_export $share_mount"
	done

	# Mount no-export folders (should be inside exported folders)
	for share in ${noexport[@]}; do
		local share_=(${share//:/ });
		local share_export="${share_[0]}"
		local share_mount="${share_[1]}"
		# Add new exports
		echo "Mounting local $share_export to $share_mount..."
		docker-machine ssh "$machine_name" \
			"sudo mkdir -p $share_mount ;
			sudo umount $share_mount 2>/dev/null ;
			sudo mount -t nfs -o noacl,async $nfs_ip:$share_export $share_mount"
	done
}

docker_machine_mounts ()
{
	if [[ "$(docker_machine_provider)" == 'virtualbox' ]]; then
		if is_mac; then
			echo-green "Configuring NFS shares..."
			docker_machine_mount_nfs "/Users:/Users" --no-export="$HOME:/.home"
		elif is_windows; then
			# TODO: implement docker-machine-smb
			# docker-machine-smb "$DOCKER_MACHINE_NAME" --shared-folder="/Users"
			echo-red "dsh: mount shares manually with docker-machine-smb"
		fi
	fi
}

#------------------------------- VM Commands -----------------------------------

vm ()
{
	check_binary_found 'docker-machine'

	if ! is_docker_machine_exist && [[ "$1" != "start" ]] && [[ "$1" != "create" ]]; then
		 echo-yellow "Docker machine $DOCKER_MACHINE_NAME is not created. Use 'dsh up' or 'dsh vm start'."
		 return 1
	fi

	case $1 in
		create)
			# usage: dsh vm create <machine_name> --provider="<provider_name>"
			shift
			eval $(parse_params "$@")
			is_docker_machine_exist "${ARGV[0]}" && echo "Machine \"${ARGV[0]}\" already exists." && return 1
			docker_machine_create "${ARGV[0]}" "$provider"
			;;
		active)
			# TODO: ability to set to NONE for linux to use docker directly
			# Get/Set active vm
			shift
			if [[ "$1" == "" ]]; then
				echo "$DOCKER_MACHINE_NAME ($(docker_machine_provider))"
			else
				[[ "$1" == "$DOCKER_MACHINE_NAME" ]] && echo "$1 is already active" && return 1
				! is_docker_machine_exist "$1" && echo "No docker machine with name $1" && return 1
				mkdir -p "$DRUDE_MACHINE" || return 1
				echo "$1" | tee "$DRUDE_MACHINE_ACTIVE" >/dev/null && echo "$1 is set active"
			fi
			;;
		start)
			if is_docker_machine_running; then
				echo "Machine \"$DOCKER_MACHINE_NAME\" is already running."
			else
				docker_machine_start
			fi
			;;
		restart)
			docker_machine_stop && docker_machine_start
			;;
		status)
			shift
			local machine_name="${1:-$DOCKER_MACHINE_NAME}"
			docker-machine status "$machine_name"
			;;
		stop)
			docker_machine_stop
			;;
		ssh)
			shift
			docker-machine ssh "$DOCKER_MACHINE_NAME" "$@"
			;;
		stats)
			vm-stats
			;;
		kill)
			shift
			local machine_name="${1:-$DOCKER_MACHINE_NAME}"
			docker-machine kill "$machine_name"
			;;
		ls|list)
			docker-machine ls
			;;
		rm)
			shift
			local machine_name="${1:-$DOCKER_MACHINE_NAME}"
			docker-machine rm "$machine_name"
			;;
		ip)
			shift
			local machine_name="${1:-$DOCKER_MACHINE_NAME}"
			docker-machine ip "$machine_name"
			;;
		env)
			shift
			local machine_name="${1:-$DOCKER_MACHINE_NAME}"
			docker-machine env "$machine_name"
			;;
		ram)
			shift
			vm-ram "$@"
			;;
		*)
			show_help_vm
			;;
	esac
}

vm-stats ()
{
	check_docker_running # should be running
	check_vbox_version
	metrics="CPU/Load/User,CPU/Load/Kernel,Disk/Usage/Used,RAM/Usage/Used,Net/Rate/Rx,Net/Rate/Tx"
	$vboxmanage metrics setup --period 1 --samples 1 "$DOCKER_MACHINE_NAME"
	sleep 1
	$vboxmanage metrics query "$DOCKER_MACHINE_NAME" $metrics
}

vm-ram () {
	echo "Current $(VBoxManage showvminfo "$DOCKER_MACHINE_NAME" | grep Memory)"
	if [[ "$1" != "" ]]; then
		local running
		is_docker_machine_running && running=1
		_confirm "Continue changing Memory size to ${1}MB?"
		[[ $running == 1 ]] && docker_machine_stop
		$vboxmanage modifyvm "$DOCKER_MACHINE_NAME" --memory "$1" && \
			echo "Memory size updated."
		[[ $running == 1 ]] && docker_machine_start
	fi
}

#------------------------------- Other Commands -----------------------------------

# Start containers
up ()
{
	if is_linux || is_docker_beta || is_docker_machine_running; then
		check_yml
		_start_containers
	else
		docker_machine_start && \
			[[ "$(get_yml_path)" != "" ]] && \
			_start_containers
	fi
}

# Stop containers
down ()
{
	check_dsh_environment
	_stop_containers "$@"
}

# Restart container(s)
# @param $1 container_name
restart ()
{
	check_dsh_environment
	_restart_containers "$@"
}

# output status of Drude if stopped or containers if started
# @param $1 Show containers from all projects (-a)
status ()
{

	if [[ "$1" == "-a" ]] || [[ "$1" == "--all" ]]; then
		check_docker_running
		docker ps
	else
		check_dsh_environment
		docker_compose ps
	fi
}

# Add key to ssh-agent or run ssh-add with provided @param
# @param $1 -D, -l or path to custom key
ssh_add () {
	# Check if ssh-agent container is running
	local running=$(docker inspect --format="{{ .State.Running }}" ssh-agent 2>/dev/null)
	[[ "$running" != "true" ]] && return

	local ssh_path="$HOME/.ssh"
	local key_path=""
	# Home folder mount in boot2docker
	if ! is_linux; then
		ssh_path="/.home/.ssh"
	fi

	case "$1" in
		"")
			if (docker exec -it ssh-agent ssh-add -l >/dev/null); then
				return; # Some key is present
			fi
			;;
		-D)
			docker run --rm --volumes-from=ssh-agent -it "${IMAGE_SSH_AGENT}:${DRUDE_ITAG}" ssh-add -D
			exit
			;;
		-l)
			# We do a sed hack here to strip out '/root/.ssh' from the key path in the output from ssh-add, since this path may confuse people.
			docker run --rm --volumes-from=ssh-agent -it "${IMAGE_SSH_AGENT}:${DRUDE_ITAG}" ssh-add -l 2>&1 | sed 's/\/root\/.ssh\///g'
			exit
			;;
		*)
			key_path="/root/.ssh/$1"
			# We check $HOME here regardless Linux or Mac/Windows (boot2docker)
			# $HOME is mounted as /.home in boot2docker
			if [ ! -f "$HOME/.ssh/$1" ]; then
				echo-red "SSH key file not found: $HOME/.ssh/$1"
				exit
			fi
			;;
	esac

	echo "Press ENTER or CTRL+C to skip entering passphrase."
	# $ssh_path is mounted as /root/.ssh in the ssh-agent containers.
	# When $key_path is empty, ssh-agent will be looking for both id_rsa and id_dsa in the home directory.
	# We do a sed hack here to strip out '/root/.ssh' from the key path in the output from ssh-add, since this path may confuse people.
	docker run --rm --volumes-from=ssh-agent -it -v "$ssh_path:/root/.ssh" "${IMAGE_SSH_AGENT}:${DRUDE_ITAG}" ssh-add "$key_path" 2>&1 | sed 's/\/root\/.ssh\///g'
}

#----- Installations and updates -----

# Install required software on Mac or Win. Check installed software on Linux
install_prerequisites ()
{
	echo-green "Installing prerequisites..."

	if [[ -x "$DOCKER_BIN" ]] && [[ -x "$DOCKER_COMPOSE_BIN" ]] && [[ -x "$DOCKER_MACHINE_BIN" ]]; then
		if is_docker_machine_exist && ! is_docker_machine_running; then
			echo-error "Docker Machine '$DOCKER_MACHINE_NAME' exists but is not running" \
				"Please start it with ${yellow}dsh up${NC} first (or destroy it with ${yellow}dsh destroy${NC} if you want it re-created)."
			return 1
		elif is_docker_running; then
			# it's an upgrade
			_stop_containers --all
			echo-green "Updating Drude system containers..."
			update_system_images
		fi
	fi

	is_windows && \
		install_prerequisites_windows && \
		return

	is_linux && \
		install_prerequisites_ubuntu && \
		return

	is_mac && \
		install_prerequisites_mac && \
		return

	echo-error "Your OS is not supported" && return 1
}

install_proxy_service ()
{
	docker rm -f vhost-proxy >/dev/null 2>&1 || true
	docker run -d --name vhost-proxy --label "group=system" --restart=always --privileged --userns=host \
		-p 80:80 -p 443:443 \
		-v /var/run/docker.sock:/var/run/docker.sock \
		"${IMAGE_VHOST_PROXY}:${DRUDE_ITAG}" >/dev/null
}

# @param $1 ip address defaults to 0.0.0.0
install_dns_service ()
{
	# Use default DNS on Linux and VirtualBox's buit-in DNS if using boot2docker
	local dns
	local ip="${1:-0.0.0.0}"
	if is_linux; then dns="$DRUDE_DEFAULT_DNS"; else dns="$DRUDE_VBOX_DNS"; fi

	# Support for boot2docker-vagrant
	local docker_ip_map="-p 172.17.42.1:53:53/udp"
	if is_linux; then docker_ip_map=""; fi
	   
	docker rm -f dns >/dev/null 2>&1 || true
	docker run -d --name dns --label "group=system" --restart=always --privileged --userns=host \
		-p "$ip":53:53/udp --cap-add=NET_ADMIN --dns "$dns" \
		-e DRUDE_IP="$ip" \
		-v /var/run/docker.sock:/var/run/docker.sock \
		"${IMAGE_DNS}:${DRUDE_ITAG}" >/dev/null
}

# Configuring sytem-wide *.drude resolver (Windows not supported)
# TODO: change this function to work properly with DO provider
configure_resolver ()
{
	check_docker_running
	local DRUDE_IP="0.0.0.0"

	if is_mac; then
		DRUDE_IP=$(docker-machine ip "$DOCKER_MACHINE_NAME")
		install_dns_service "$DRUDE_IP"
		if (grep "nameserver $DRUDE_IP" /etc/resolver/drude 2>/dev/null 1>/dev/null); then
			return
		fi
		sudo mkdir -p /etc/resolver
		echo -e "\n# .drude domain resolution\nnameserver $DRUDE_IP" | \
			sudo tee 1>/dev/null /etc/resolver/drude
	elif is_linux; then
		DRUDE_IP="192.168.10.10"
		install_dns_service "$DRUDE_IP"
		# TODO remove old record
		echo -e "\n# .drude domain resolution\nnameserver $DRUDE_IP" | \
			sudo tee -a /etc/resolvconf/resolv.conf.d/head
		sudo resolvconf -u
	elif is_windows; then
		DRUDE_IP=$(docker-machine ip "$DOCKER_MACHINE_NAME")
		install_dns_service "$DRUDE_IP"
		echo -e "You can configure ${yellow}.drude${NC} domain resolution manually"
		echo -e "by setting ${yellow}$DRUDE_IP${NC} as your primary DNS server in network settings."
	fi
}

install_sshagent_service ()
{
	docker rm -f ssh-agent >/dev/null 2>&1 || true
	docker run -d --name ssh-agent --label "group=system" --restart=always --privileged --userns=host \
		-v /var/run/docker.sock:/var/run/docker.sock \
		"${IMAGE_SSH_AGENT}:${DRUDE_ITAG}" >/dev/null
}

# Install prerequisites on Mac
install_prerequisites_mac ()
{
	is_tty || return 1 # only allow in interactive shell
	# Check VirtualBox
	if ! is_binary_found 'VBoxManage'; then
		echo-error "VBoxManage executable was not found. Virtual Box is required to run Drude on Mac." \
			&& exit 1
	elif ! is_vbox_version; then
		echo-error "Required Virtual Box version is $DSH_REQUIREMENTS_VBOX or higher" \
			&& exit 1
	else
		# Kill the default adapter and DHCP server to avoid network issues down the road
		VBoxManage dhcpserver remove --netname HostInterfaceNetworking-vboxnet0 > /dev/null 2>&1
		VBoxManage hostonlyif remove vboxnet0 > /dev/null 2>&1
	fi

	mkdir -p "$DRUDE_DOWNLOADS_DIR" 2>/dev/null
	if_failed "Could not create $DRUDE_DOWNLOADS_DIR"

	# Install Docker client
	if ! is_docker_version; then
		echo-green "Installing docker client v${DSH_REQUIREMENTS_DOCKER}..."
		(cd "$DRUDE_DOWNLOADS_DIR" && \
			curl -sSL "$URL_DOCKER_MAC" | tar zxf - && \
			mv "docker/docker" "$DRUDE_BIN_DIR/")
	fi

	# Install docker-compose
	if ! is_docker_compose_version; then
		echo-green "Installing docker-compose v${DSH_REQUIREMENTS_DOCKER_COMPOSE}..."
		curl -sSL "$URL_DOCKER_COMPOSE_MAC" -o "$DOCKER_COMPOSE_BIN" && \
			chmod +x "$DOCKER_COMPOSE_BIN"
	fi

	# Install docker-machine
	if ! is_docker_machine_version; then
		echo-green "Installing docker-machine v${DSH_REQUIREMENTS_DOCKER_MACHINE}..."
		curl -sSL "$URL_DOCKER_MACHINE_MAC" -o "$DOCKER_MACHINE_BIN" && \
			chmod +x "$DOCKER_MACHINE_BIN"
	fi

	# Cleanup
	rm -rf "$DRUDE_DOWNLOADS_DIR" >/dev/null 2>&1

	# If it was an upgrade
	is_docker_machine_running && \
		( echo-green "Upgrading Docker Machine..." && \
			docker-machine upgrade "$DOCKER_MACHINE_NAME") && \
			reset system

	echo-green "Prerequisites installation finished."
}

install_prerequisites_windows ()
{
	# Check Virtual Box
	if ! is_vbox_version; then # TODO: check_vbox_version should say where it looks for vbox. Not found or versions wrong?
		echo-error "Required Virtual Box version is $DSH_REQUIREMENTS_VBOX or higher" \
			&& exit 1
	else
		echo-green "Killing the default VirtualBox adapter and DHCP server to avoid network issues down the road"
		winsudo "$vboxmanage" dhcpserver remove --netname "HostInterfaceNetworking-VirtualBox Host-Only Ethernet Adapter"
		winsudo "$vboxmanage" hostonlyif remove "VirtualBox Host-Only Ethernet Adapter"
	fi

	mkdir -p "$DRUDE_DOWNLOADS_DIR" 2>/dev/null
	if_failed "Could not create $DRUDE_DOWNLOADS_DIR"

	# Install Docker client
	if ! is_docker_version; then
		echo-green "Installing docker client v${DSH_REQUIREMENTS_DOCKER}..."
		(cd "$DRUDE_DOWNLOADS_DIR" && \
			curl -sSL "$URL_DOCKER_WIN" | tar zxf - && \
			mv "docker/docker" "$DOCKER_BIN" && \
			chmod +x "$DOCKER_BIN")
	fi

		# Install Docker Compose
	if ! is_docker_compose_version; then
		echo-green "Installing docker-compose v${DSH_REQUIREMENTS_DOCKER_COMPOSE}..."
		curl -sSL "$URL_DOCKER_COMPOSE_WIN" -o "$DOCKER_COMPOSE_BIN" && \
			chmod +x "$DOCKER_COMPOSE_BIN"
	fi

		# Install Docker Machine
	if ! is_docker_machine_version; then
		echo-green "Installing docker-machine v${DSH_REQUIREMENTS_DOCKER_MACHINE}..."
		curl -L "$URL_DOCKER_MACHINE_WIN" -o "$DOCKER_MACHINE_BIN" && \
			chmod +x "$DOCKER_MACHINE_BIN"
	fi

	# Install docker-machine-smb
	if [[ ! -x "$DOCKER_MACHINE_SMB_BIN" ]]; then
		echo-green "Installing docker-machine-smb..."
		curl -s "$URL_DOCKER_MACHINE_SMB" -o "$DOCKER_MACHINE_SMB_BIN" > /dev/null && \
			chmod +x "$DOCKER_MACHINE_SMB_BIN"
	fi

	# Install winpty TODO: check winpty version here
	echo-green "Installing winpty v${DSH_REQUIREMENTS_WINPTY}..."
	(cd "$DRUDE_DOWNLOADS_DIR" && \
		curl -sSL "$URL_WINPTY" | tar -xzf - && \
		mv "winpty-*/bin/*" "$DRUDE_BIN_DIR/")

	# Cleanup
	rm -rf "$DRUDE_DOWNLOADS_DIR" >/dev/null 2>&1

	# Git settings
	echo-green "Adjusting git defaults..."
	echo "git config --global core.autocrlf input"
	git config --global core.autocrlf input # do not convert line breaks. treat as is
	echo "git config --system core.longpaths true"
	git config --system core.longpaths true # support long paths

	# If it was an upgrade
	is_docker_machine_running && \
		( echo-green "Upgrading Docker Machine..." && \
			docker-machine upgrade "$DOCKER_MACHINE_NAME") && \
			reset system

	echo-green "Prerequisites installation finished."
}

# Install Docker and setup Drude on Ubuntu 14.04+
install_prerequisites_ubuntu ()
{
	is_tty || return 1 # only allow in interactive shell
	if ! is_ubuntu; then
		echo-red "dsh: prerequisites installation is currently supported only on Ubuntu 14.04+"
		echo-yellow "You can continue at your own risk, if you know your Linux distribution is compatible with Ubuntu 14.04+"
		_confirm "Are you sure you want to continue?"
	fi

	# Install Docker client
	if ! is_docker_version; then
	echo-green "Installing Docker..."
		# Stop docker dervice if it exists
		if sudo service docker status 2>/dev/null; then
			echo "Stopping docker service..."
			sudo service docker stop 2>/dev/null
		fi
		curl -sSL https://get.docker.com/ | sh && \
			sudo usermod -aG docker $(whoami)
		sudo service docker start 2>/dev/null
		sudo docker version
		if_failed "Docker installation/upgrade has failed."
	fi

	# Install Docker Compose
	if ! is_docker_compose_version; then
		echo-green "Installing Docker Compose..."
		sudo curl -sSL "$URL_DOCKER_COMPOSE_NIX" && \
			sudo chmod +x /usr/local/bin/docker-compose && \
			docker-compose --version
		if_failed "Docker Compose installation/upgrade has failed."
	fi

	# Adding a subnet for Drude. Make sure we don't do this twice
	if ! grep -q "$DRUDE_SUBNET" /etc/network/interfaces; then
		echo-green "Adding a subnet for Drude..."
		cat > /tmp/drude.ip.addr <<EOF
	up   ip addr add ${DRUDE_SUBNET} dev lo label lo:drude
	down ip addr del ${DRUDE_SUBNET} dev lo label lo:drude
EOF
		sudo sed -i '/iface lo inet loopback/r /tmp/drude.ip.addr' /etc/network/interfaces
		rm -f /tmp/drude.ip.addr
		sudo ifdown lo && sudo ifup lo
	fi

	reset proxy
	reset dns
	reset ssh-agent

	echo-green "To run docker without sudo please re-login or run 'newgrp docker' now."
}

# Download latest Drude config file
install_drude_config ()
{
	testing_warn
	[ -f "docker-compose.yml" ] && _confirm "Overwrite existing docker-compose.yml?"
	local docker_compose_yml
	docker_compose_yml=$(curl -kfsS "$URL_DRUDE_CONFIG")
	if_failed "Could not get latest docker-compose.yml version."

	echo "$docker_compose_yml" | tee "docker-compose.yml" >/dev/null
	if_failed "Could not write to docker-compose.yml"
	echo-green "Latest version of docker-compose.yml was downloaded."
}

# Install shell commands autocomplete script
install_autocomplete ()
{
	local autocomplete_script
	autocomplete_script=$(curl -kfsS "$URL_BASH_AUTOCOMPLETE")
	if_failed "Autocomplete script download has failed"

	destination="/usr/local/bin/dsh-bash-autocomplete"
	echo "$autocomplete_script" | tee "$destination" >/dev/null
	if_failed "Failed to write file to $destination"
	echo-green "Script saved to $destination"
	chmod +x "$destination"

	SOURCE_FILE=".bash_profile"
	grep -q "$destination" "$HOME/$SOURCE_FILE"
	if [[ $? -ne 0 ]]; then
		echo -e ". $destination" >> "$HOME/$SOURCE_FILE"
		if_failed "Failed to write file to $HOME/$SOURCE_FILE"
		echo-green "Autocomplete appended to $HOME/$SOURCE_FILE"
		echo-yellow "dsh: Please restart your bash session to apply"
	fi
}

# Install prerequisites, drude config or autocomplete
install ()
{
	if [[ "$1" == "prerequisites" ]]; then
		install_prerequisites
	elif [[ "$1" == "drude-config" ]]; then
		install_drude_config
	elif [[ "$1" == "autocomplete" ]]; then
		install_autocomplete
	fi
}

# Update system conteainers' images
update_system_images ()
{
	check_docker_running
	docker pull "${IMAGE_VHOST_PROXY}:${DRUDE_ITAG}"
	docker pull "${IMAGE_DNS}:${DRUDE_ITAG}"
	docker pull "${IMAGE_SSH_AGENT}:${DRUDE_ITAG}"
}

# Update all containers images
update_images ()
{
	check_dsh_environment
	update_system_images
	docker_compose pull # update project containers images
	reset system
	up
}

# Update dsh itself
update_dsh ()
{
	[[ "$1" != "" ]] && DRUDE_BRANCH="$1"
	testing_warn
	echo "Downloading..."
	local new_dsh
	new_dsh=$(curl -kfsS "$URL_DSH")
	if_failed "Download has failed."

	# Check if update is a major version. Show warning is needed
	local new_version=$(echo "$new_dsh" | grep "^DSH_VERSION=" | cut -f 2 -d "=")
	local current_major_version=$(echo "$DSH_VERSION" | cut -d "." -f 1)
	local new_major_version=$(echo "$new_version" | cut -d "." -f 1)
	if [[ "$current_major_version" != "$new_major_version" ]]; then
		echo -e "${red_bg} WARNING ${NC} ${red}Non-backwards compatible version update${NC}"
		echo -e "Updating from ${yellow}$DSH_VERSION${NC} to ${yellow}$new_version${NC} is a non-backwards compatible update."
		echo "You might be not able to use you current Drude environment if you proceed."
		echo -e "Please read update documentation: ${yellow}$URL_DRUDE_REPO_UI#updates${NC}"
		_confirm "Continue with the update?"
	fi

	# check for different updates on next run
	rm -r "$DRUDE_LAST_CHECK" >/dev/null 2>&1

	# saving to file
	echo "$new_dsh" | sudo tee /usr/local/bin/dsh > /dev/null
	if_failed "Could not write /usr/local/bin/dsh."
	sudo chmod +x /usr/local/bin/dsh

	local new_version=$(head /usr/local/bin/dsh | grep "^DSH_VERSION=" | cut -f 2 -d "=")
	echo-green "dsh updated to ${new_version}"
	exit
}

check_for_updates ()
{
	# Never trigger in scripts
	if ! is_tty; then return; fi

	local timestamp; local last_check; local next_check
	timestamp=$(date +%s)
	last_check=$(cat $DRUDE_LAST_CHECK 2>/dev/null)
	# Set last_check to 0 if empty
	last_check="${last_check:-0}"
	# Check once a week
	next_check=$(($last_check+604800))
	if [ $timestamp -le $next_check ]; then
		return;
	fi

	echo 'dsh: checking for updates...'
	local new_dsh; local new_version
	# Always write current timestamp to last check file
	echo "$timestamp" > "$DRUDE_LAST_CHECK"
	# No -S for curl here to be completely silent. Connection timeout 1 sec, total max time 3 sec or fail
	new_dsh=$(curl -kfs --connect-timeout 1 --max-time 3 "$URL_DSH")
	new_version=$(echo "$new_dsh" | grep "^DSH_VERSION=" | cut -f 2 -d "=")
	if [ $(ver_to_int "$new_version") -gt $(ver_to_int $DSH_VERSION) ]; then
		echo-green-bg " UPDATE AVAILABLE "
		echo -e "${green}dsh${NC} [ $DSH_VERSION --> $new_version ] (run ${green}dsh update dsh${NC} to update)"
		echo "Press Enter."
		read -p ''
	fi
}

#-------------------------- Execution commands -----------------------------

# Start an interactive bash session in a container
# @param $1 container name
_bash ()
{
	check_docker_running
	# Interactive shell requires a tty.
	# On Windows we assume we run interactively via winpty (console.exe).
	if ! is_tty; then
		echo "Interactive bash console in a non-interactive enveronment!? Nope, won't happen."
		return 1
	fi

	# Pass container name to _run
	CONTAINER_NAME=$1 _run bash -i
}

# Run a command in the cli container changing dir to the same folder
# @param $* command with it's params to run
_run ()
{
	[[ $1 == "" ]] && \
		show_help_exec && exit
	check_dsh_environment

	# CONTAINER_NAME can be used to override where to run. Used in _bash()
	if [[ "$CONTAINER_NAME" == "" ]]; then CONTAINER_NAME='cli'; fi
	container_id=$(get_container_id "$CONTAINER_NAME")

	# 1) check winpty
	# Running docker exec interactively on Windows requires workarounds
	is_windows && check_binary_found 'winpty' && winpty_cmd='winpty'

	# 2) cmd
	local cmd

	local cdir
	# Only chdir to the same dir in cli container
	# RUN_NO_CDIR can be used to override this (used in mysql_import)
	if [[ "$CONTAINER_NAME" == "cli" ]] && [[ "$RUN_NO_CDIR" != 1 ]]; then
		local path=$(get_current_relative_path)
		if [[ "$path" != "$(pwd)" ]] && [[ "$path" != "" ]] ; then
			# we're inside docroot
			cdir="cd $path &&"
		fi
	fi

# TODO: possibly can be removed
#	local columns
#	if is_tty ; then
#		columns="export COLUMNS=$(tput cols 2>/dev/null || echo 80) &&"
#	fi

	cmd="$cdir"

	# 3) convert array of parameters into escaped string
	# Escape spaces that are "spaces" and not parameter delimeters (i.e. param1 param2\ with\ spaces param3)
	if [[ $2 != "" ]]; then
		cmd="$cmd "$(printf " %q" "$@")
	# Do not escape spaces if there is only one parameter (e.g. dsh run "ls -la | grep txt")
	else
		cmd="$cmd $@"
	fi
	
	# 4) execute
	if [[ "$container_id" == "" ]]; then
		# try to connect to this out of project container by name
		$winpty_cmd docker exec -it "$CONTAINER_NAME" sh -i
		return
	fi

	if is_tty ; then
		# interactive
		$winpty_cmd docker exec -it "$container_id" bash -ic "$cmd"
	else
		# non-interactive
		docker exec "$container_id" bash -c "$cmd"
	fi
}

# start interactive mysql shell
mysql ()
{
	check_dsh_environment
	check_drush_path
	_run $(get_mysql_connect)" -A" # -A option to speed up mysql load
}

# Truncate db and import from sql dump
# @param $1 filename of backup file. Should be inside project root
mysql_import ()
{
	check_dsh_environment
	check_drush_path

	local confirm=1
	if [[ "$1" == "-y" ]] || [[ "$2" == "-y" ]]; then
		confirm=0
		if [[ "$1" == "-y" ]]; then
			shift #remove this param if -y was first
		fi
	fi

	project_root=$(get_yml_path)
	local filename=$(basename $1)
	local filepath=$(get_abs_path $1)
	#substract project root path from filepath
	local pathdiff=${filepath#$project_root}

	if [[ "$pathdiff" == "$filepath" ]] ; then
		# substraction did not succeed because file is outside project root
		echo "\"$filename\" should be inside your project root folder"
		return
	fi

	if [ $confirm -eq 1 ]; then
		_confirm "[!] This will drop the existing database. Continue?"
	fi

	#_run drush sql-drop -y
	local sql_connect
	sql_connect=$(get_mysql_connect)
	echo "Importing $filename into the database..."

	# Use pv for interactive shells only.
	if is_tty ; then
		# Check if we have a gzipped dump and treat it differently.
		if [[ "$filename" == *.gz ]]; then
			file_size=$(gzip -l $1 | sed -n 2p | awk '{print $2}')
			RUN_NO_CDIR=1 _run "zcat ./$pathdiff/$filename | pv --size $file_size | $sql_connect"
		else
			RUN_NO_CDIR=1 _run "pv ./$pathdiff/$filename | $sql_connect"
		fi
	else
		# Check if we have a gzipped dump and treat it differently.
		if [[ "$filename" == *.gz ]]; then
			RUN_NO_CDIR=1 _run "zcat ./$pathdiff/$filename | $sql_connect"
		else
			RUN_NO_CDIR=1 _run "cat ./$pathdiff/$filename | $sql_connect"
		fi
	fi

	# Check if import succeded or not and print results.
	if [ $? -eq 0 ]; then
		echo-green "dsh: mysql-import finished";
		if is_tty; then _notify "Dsh" "Mysql import finished"; fi
	else
		echo-red "dsh: mysql-import failed";
		if is_tty; then _notify "Dsh" "Mysql import failed!"; fi
	fi
}

# Run Behat tests (also install dependencies through Composer)
# @param $* arguments and params passed to Behat
behat ()
{
	check_dsh_environment
	cd $(get_yml_path)

	local params=''
	local path='tests/behat'
	for i in "$@"; do
		case "$i" in
			--path=*)
				path="${i#*=}"
				;;
			*)
				params="$params$i "
				;;
		esac;
	done

	local project_root_path=$(get_yml_path)
	local behat_yml_path="${project_root_path}/${path}/behat.yml"
	if [[ ! -f "${behat_yml_path}" ]]; then
		echo-red "Could not find ${behat_yml_path}"
		exit 1
	fi
	_run "cd $path && composer install --prefer-source --no-interaction"
	_run "cd $path && bin/behat -p docker $params"
}

# Download script by URL and execute it
# @param $1 url of script.
exec_url ()
{
	if [[ "$1" != "" ]]; then
		_confirm "Are you sure you want to run script from '$1'?"
		local script
		script=$(curl -kfsSL "$1")
		if_failed "Failed downloading script $1"
		shift
		(eval "${script}")
	else
		show_help_exec-url
	fi
}

# Remove container(s)
# @param $1 $2... container names
remove ()
{
	check_dsh_environment
	if [[ $1 == "" ]]; then
		echo -e  "${red}WARNING:${NC} ${yellow}You have chosen to delete or re-create all project containers.${NC}"
		_confirm "Continue?";
	fi

	# support quiet removal
	if [[ $1 == "-f" ]]; then
		shift
	fi

	_remove_containers "$@"
}

# Reset container(s) (stop, remove, up)
# @param $1 $2... containers names
reset ()
{
	check_docker_running

	if [[ "$1" == "proxy" ]] ; then
		echo-green 'Resetting Drude HTTP/HTTPS reverse proxy service...'
		install_proxy_service
		return
	fi

	if [[ "$1" == "dns" ]] ; then
		echo-green 'Resetting Drude DNS service and configuring resolver for .drude domain...'
		configure_resolver
		return
	fi

	if [[ "$1" == "ssh-agent" ]] ; then
		echo-green 'Resetting Drude ssh-agent service...'
		install_sshagent_service
		return
	fi

	if [[ "$1" == "system" ]] ; then
		echo-green 'Resetting Drude services...'
		echo ' * vhost-proxy'
		install_proxy_service
		echo ' * dns and resolver for .drude domain'
		configure_resolver
		echo ' * ssh-agent'
		install_sshagent_service
		return
	fi

	check_yml
	# support quiet removal
	if [[ $1 == "-f" ]]; then
		shift
		remove -f "$@"
	else
		remove "$@"
	fi
	_start_containers
}

# Show logs
# @param $* container(s) name
logs ()
{
	check_docker_running
	docker_compose logs "$@"
}

# Set uid of the primary "docker" user in the cli container
# Useful to match the host uid with the uid in the cli container and avoid file permission issues this way.
_set_cli_uid ()
{
	[[ "$(docker_machine_provider)" != 'virtualbox' ]] && return # only run for virtualbox. others will sync other ways
	if [[ "$DRUDE_SET_UID" == "" ]] ; then
		DRUDE_SET_UID=$(id -u)
	fi
	# Let uid to be set with the DRUDE_SET_UID env variable
	if [[ "$DRUDE_SET_UID" != 0 ]] ; then
		local host_uid="$DRUDE_SET_UID"
		local container_uid=$(docker exec $(get_container_id cli) id -u)

		if [[ "$container_uid" != "$host_uid" ]]; then
			echo-green "Changing user uid in cli from $container_uid to $host_uid..."
			docker exec -u root $(get_container_id cli) usermod -u "$host_uid" docker
			echo-green "Reseting permissions on /var/www..."
			docker exec -u root $(get_container_id cli) chown -R docker:users /var/www
			echo-green "Restarting php daemon..."
			# TODO: Remove. This code is to support legacy cli image version, where php5-fpm service name was used.
			local php_service='php-fpm';
			local local res=$(docker exec $(get_container_id cli) grep "program:php5-fpm" /etc/supervisor/conf.d/supervisord.conf)
			if [[ "$res" != '' ]]; then php_service='php5-fpm'; fi
			docker exec -u root $(get_container_id cli) supervisorctl restart "$php_service" >/dev/null
		else
			echo-green "Container and host uids already match ($container_uid)."
		fi
	else
		echo-yellow "Running Drude as root is not recommended. Please run as a regular user with docker access."
	fi
}

_system_information_heading ()
{
	local dashes_length=$((32+${#1}))
	echo
	printf 'â€“%.0s' $(seq 1 ${dashes_length})
	echo
	echo "		$1"
	printf 'â€“%.0s' $(seq 1 ${dashes_length})
	echo
}

system_information ()
{
	_system_information_heading "OS"
	uname -a
	if is_linux; then
		[ -f /etc/os-release ] && cat /etc/os-release
		[ -f /etc/system-release ] && cat /etc/system-release
	fi
	echo -n "Current dir: "
	pwd

	_system_information_heading "Dsh"
	version

	_system_information_heading "Docker & Docker Compose"
	echo "DOCKER_HOST:	$DOCKER_HOST"
	echo
	echo "Docker: $(docker version)"
	echo "Docker Compose: $(docker_compose version)"

	if ! is_linux; then
		_system_information_heading "VirtualBox"
		VBoxManage --version

		_system_information_heading "Running Virtual Boxes"
		VBoxManage list runningvms

		_system_information_heading "VirtualBox Network interfaces"
		VBoxManage list hostonlyifs

		_system_information_heading "Docker Machine"
		docker-machine --version
		echo
		docker-machine ls
	fi

	echo
}

#-------------------------- Links / Aliases -----------------------------

# param $1 path
# param $2 alias name
alias_create ()
{
	[[ $# != 2 ]] && echo 'Usage: dsh alias <path> <alias_name>' && exit 1
	mkdir -p "$DRUDE_CONFIG_ALIAS" || exit 1
	[[ -h "$2" ]] && echo "Alias $2 already exists" && exit 1
	[[ -e "$2" ]] && echo "Filename is not available" && exit 1
	[[ ! -d "$1" ]] && echo 'Path should be a valid dir' && exit 1

	! is_windows && \
		ln -s $(get_abs_path "$1") "$DRUDE_CONFIG_ALIAS/$2"
}

alias_remove () {
	[[ ! -h "$DRUDE_CONFIG_ALIAS/$1" ]] && echo 'Alias not found' && exit
	[[ -h "$DRUDE_CONFIG_ALIAS/$1" ]] && rm "$DRUDE_CONFIG_ALIAS/$1"
}

alias_list ()
{
	local list=$(ls -l "$DRUDE_CONFIG_ALIAS" 2>/dev/null | grep -v total | awk '{printf "    %-15s %s %s\n", $9, $10, $11}')
	[[ "$list" == "" ]] && echo "No aliases found" && exit
	echo "$list"
}

#-------------------------- Parameters parsing -----------------------------

# Handle alias first
if [[ "$1" == "@"* ]]; then
	DRUDE_ALIAS=${1#@}
	[[ ! -h "$DRUDE_CONFIG_ALIAS/$DRUDE_ALIAS" ]] && echo-red "No such alias $1" && exit 1
	cd "$DRUDE_CONFIG_ALIAS/$DRUDE_ALIAS" 2>/dev/null
	if_failed_error "Could not navigate to directory linked by $1 alias"
	shift
fi

# Check for updates if not updating already
if [[ "$*" != "update dsh" ]]; then
	check_for_updates
fi

# Parse other parameters
case "$1" in
	up|start)
		shift
		up
		;;
	stop|down)
		shift
		down "$@"
		;;
	restart)
		shift
		restart "$@"
		;;
	status|st|ps)
		shift
		status "$@"
		;;
	reset)
		shift
		reset "$@"
		;;
	remove)
		shift
		remove "$@"
		;;
	vm)
		shift
		vm "$@"
		;;
	install)
		shift
		install "$@"
		;;
	update)
		shift
		if [[ "$1" == "prerequisites" ]]; then
			install_prerequisites
		elif [[ "$1" == "images" ]]; then
			update_images
		elif [[ "$1" == "dsh" ]]; then
			shift
			update_dsh "$@"
		else
			show_help_update
		fi
		;;
	self-update)
		shift
		update_dsh "$@"
		;;
	bash)
		shift
		_bash "$@"
		;;
	exec|run)
		shift
		_run "$@"
		;;
	mysql|sqlc)
		mysql
		;;
	mysql-import|sqli)
		mysql_import "$2" "$3"
		;;
	drush)
		shift
		if [[ $1 == "" ]]; then
			_run drush
		else
			_run drush "$@"
		fi
		;;
	drupal)
		shift
		if [[ "$1" == "" ]]; then
			_run drupal
		else
			_run drupal "$@"
		fi
		;;
	behat)
		shift
		behat "$@"
		;;
	ssh-add)
		shift
		ssh_add "$@"
		;;
	docker)
		shift
		is_docker_running # exports env
		docker "$@"
		;;
	docker-compose)
		shift
		is_docker_running # exports env
		docker_compose "$@"
		;;
	exec-url)
		shift
		exec_url "$@"
		;;
	cleanup)
		shift
		_docker_cleanup $1
		;;
	-v | v)
		version --short
		;;
	version)
		version
		;;
	bash_comp_words)
		shift
		bash_comp_words "$@"
		;;
	logs)
		shift
		logs "$@"
		;;
	"")
		show_help
		;;
	help)
		show_help "$2"
		;;
	sysinfo)
		system_information
		;;
	alias)
		shift
		[[ "$*" == "" ]] && alias_list && exit
		[[ "$*" == "list" ]] && alias_list && exit
		[[ "$1" == "remove" ]] && shift && alias_remove "$@" && exit
		alias_create "$@"
		;;
	init|*)
		# Search for custom commands in $DRUDE_COMMANDS_PATH

		legacy_init_path="$(get_drude_path)/.drude/scripts/drude-init.sh"
		if [[ "$1" == "init" ]] && [[ -f "$legacy_init_path" ]]; then
			# Legacy processing for init script
			dsh_command_script="$legacy_init_path"
		else
			# Normal search for custom command
			# First search project commands folder
			dsh_command_script="$(get_drude_path)/$DRUDE_COMMANDS_PATH/$1"
			# If not found search global drude commands folder
			[ ! -f "$dsh_command_script" ] && dsh_command_script="$HOME/$DRUDE_COMMANDS_PATH/$1"
			# If not found there as well then it is a wrong command
			[ ! -f "$dsh_command_script" ] && \
				echo-yellow "dsh: unknown command '$*'. See 'dsh help' for list of available commands" && \
				exit 1
		fi

		if [[ ! -x "$dsh_command_script" ]]; then
			echo -e "${yellow}$dsh_command_script${NC} is not set to be executable."
			_confirm "Fix automatically?"
			chmod +x "$dsh_command_script"
			if_failed "Could not make $dsh_command_script executable"
		fi
		shift
		export YML_PATH="$(get_yml_path)"
		export DRUDE_PATH="$(get_drude_path)"
		export PROJECT_ROOT="$(get_drude_path)"
		if is_docker_running; then
			export DOCKER_RUNNING="true"
		else
			export DOCKER_RUNNING="false"
		fi

		exec "$dsh_command_script" "$@"
esac
