#!/bin/bash

DSH_VERSION=1.20.3

# Console colors
red='\033[0;91m'
red_bg='\033[101m'
green='\033[0;32m'
green_bg='\033[42m'
yellow='\033[1;33m'
NC='\033[0m'

#---------------------------- Global Constants --------------------------------
# Configuration path
DRUDE_CONFIG_DIR="$HOME/.drude"
DRUDE_CONFIG_BACKUP_DIR="$DRUDE_CONFIG_DIR/backups"
# Always try to create this path in case ~/.drude does not exist
mkdir -p $DRUDE_CONFIG_BACKUP_DIR

DRUDE_LAST_CHECK="$DRUDE_CONFIG_DIR/last_check"
DRUDE_B2D_VERSION="$DRUDE_CONFIG_DIR/b2d_version"

# Where custom commands live
DRUDE_COMMANDS_PATH=".drude/commands"

# Network settings
DRUDE_IP="192.168.10.10"
DRUDE_SUBNET="192.168.10.1/24"
DRUDE_DEFAULT_DNS="8.8.8.8"
DRUDE_VBOX_DNS="10.0.2.3"

#---------------------------- Global Variables --------------------------------
DOCKER_BETA="${DOCKER_BETA:-0}"

if [[ $DOCKER_BETA -eq 0 ]]; then
	DEFAULT_DOCKER_HOST="tcp://$DRUDE_IP:2375"
fi
# boot2docker-vagrant does not support Docker TLS.
# Make sure it is disabled for the current terminal session.
unset DOCKER_TLS_VERIFY
unset DOCKER_CERT_PATH

DRUDE_BRANCH="${DRUDE_BRANCH:-master}"
B2D_BRANCH="${B2D_BRANCH:-master}"

# Allow image tag overrides for system services. See install_xyz_service()
DRUDE_ITAG="${DRUDE_ITAG:-stable}"

#---------------------------- Helper functions --------------------------------

DRUDE_YML_PATH='' #yml path value will be cached here
DRUDE_PATH='' #drude path value will be cached here

echo-red () { echo -e "${red}$1${NC}"; }
echo-green () { echo -e "${green}$1${NC}"; }
echo-green-bg () { echo -e "${green_bg}$1${NC}"; }
echo-yellow () { echo -e "${yellow}$1${NC}"; }

# Exits dsh if previous command exited with non-zero code
if_failed ()
{
	if [ ! $? -eq 0 ]; then
		msg="error executing last command"
		if [[ "$1" != "" ]]; then msg="$1"; fi
		echo-red "dsh: $msg"
		exit 1
	fi
}

# Search for a file/directory in a directiry tree upwards. Return it's path.
# @param $1 filename
upfind ()
{
	if [[ $1 == '' ]]; then return 1; fi
	( #incapsulate cd
		while [[ ! -f $1 ]] && [[ ! -d $1 ]] && [[ $PWD != / ]]; do
			cd ".."
		done;
		if [[ -f $1 ]] || [[ -d $1 ]]; then echo $PWD; fi
	)
}

# Get path to docker-compose.yml using upfind
get_yml_path ()
{
	if [ -z "$DRUDE_YML_PATH" ]; then
		DRUDE_YML_PATH=$(upfind "docker-compose.yml")
	fi
	echo "$DRUDE_YML_PATH"
}

# Get path to .drude folder using upfind
get_drude_path ()
{
	if [ -z "$DRUDE_PATH" ]; then
		DRUDE_PATH=$(upfind ".drude")
	fi
	echo "$DRUDE_PATH"
}

# Returns absolute path
# @param $1 file/dir relative path
get_abs_path ()
{
	local _dir
	if [ -f $1 ]; then
		_dir=$(dirname $1)
	elif [ -d $1 ]; then
		_dir=$1
	else
		echo "Path \"$1\" does not exist"
		return
	fi
	local absolute=$( cd "${_dir}" ; pwd )
	echo "$absolute"
}

# Return current path relative to project root with trailing slash
get_current_relative_path ()
{
	# Check that we're inside project folder
	local proj_root=$(get_yml_path)
	local cwd=$(pwd)
	# if cwd substract proj_root is still cwd then it means we're out of proj_root (unsubstractable)
	# ex: cwd=/a/b/c/d, proj_root=/a/b/c, pathdiff==d
	# ex: cwd=/a/b, proj_root=/a/b/c, pathdiff==/a/b
	local pathdiff=${cwd#$proj_root/}
	echo $pathdiff
}

# Removes invisible residue from the string that remains leftover in Babun+docker-compose sometimes
# @param $1 string to cleanup
# @return clean string
clean_string ()
{
	cleaned=$(echo "$1" | sed -e 's/[^a-zA-Z0-9_-]$//')
	echo ${cleaned}
}

# Get mysql connection string
get_mysql_connect ()
{
	# Run drush forcing tty to false to avoid colored output string from drush.
	echo "$(DRUDE_IS_TTY=0 _run drush sql-connect)"
}

# Use this function for every docker-compose invocation.
docker_compose ()
{
	# docker-compose cannot find docker-compose.yml in the path if there are symlinks on the way
	cwd=$(pwd)
	cd $(get_yml_path)
	
	docker-compose $*
	res=$?
	
	# switch back to the original path
	cd $cwd
	
	return $res
}

# Get container id by service name
# @param $1 docker compose service name (e.g. cli)
# @return docker container id 
get_container_id ()
{
	# Trim CR(\r) from the output, otherwise there will be issues passing it to the docker binary on Windows.
	echo $(docker_compose ps -q $1 | tr -d '\r')
}

#------------------------- Basics check functions -----------------------------

is_linux ()
{
	if [[ $IS_LINUX == "true" ]]; then return 0; fi

	local res=$(uname | grep 'Linux')
	if [[ ! "$res" == '' ]]; then
		IS_LINUX="true"
		return 0;
	else
		return 1;
	fi
}

is_windows ()
{
	local res=$(uname | grep 'CYGWIN_NT')
	if [[ "$res" != '' ]]; then
		return 0;
	else
		res=$(uname | grep 'MINGW32_NT')
		if [[ "$res" != '' ]]; then
			echo-red "dsh: Running from Git Bash is not supported"
			exit 1
		fi
		return 1;
	fi
}

# cheсks wether we are in boot2docker console
is_boot2docker ()
{
	local res=$(uname -a|grep 'boot2docker')
	if [[ ! "$res" == '' ]]; then
		return 0;
	else
		return 1;
	fi
}

is_mac ()
{
	local res=$(uname | grep 'Darwin')
	if [[ ! "$res" == '' ]]; then
		return 0;
	else
		return 1;
	fi
}

is_docker_beta ()
{
	if [[ "$DOCKER_BETA" == "1" ]]; then
		return 0;
	else
		return 1;
	fi
}

# searches if binary exists and callable in PATH
is_binary_found ()
{
	if [[ "$1" == "" ]]; then
		return 1;
	fi

	local bpath=$(which $1 2>/dev/null)

	if [[ "$bpath" != "" ]] && [ -f $(which $1) ]; then
		return 0
	else
		return 1
	fi
}

# checks if binary exists and fails is it isn't
check_binary_found ()
{
	is_binary_found $1
	if_failed "$1 executable not found."
}

is_docker_running ()
{
	if is_linux || is_docker_beta; then
		local err
		local errcode
		# Check if docker is running via docker info.
		# This operation is instant even if docker is not running (assuming a socket is used).
		err=$(docker info >/dev/null 2>&1); errcode=$?
		# Print error details if available. We are looking for a specific case here:
		# e.g. "Error response from daemon: client is newer than server (client API version: 1.22, server API version: 1.21)"
		if [[ $err =~ 'Error' ]]; then echo $err; fi
		return $errcode
	else
		# On Mac and Windows - use netcat to check the host:port
		check_binary_found 'nc'
		if [[ $DOCKER_HOST == "" ]]; then
			return 1
		fi

		# Extract host and port from $DOCKER_HOST
		local host=$(echo $DOCKER_HOST | sed -e 's/\(tcp:\/\/\)*\([a-z0-9\.]*\):[0-9]*/\2/')
		local port=$(echo $DOCKER_HOST | sed -e 's/\(tcp:\/\/\)*[a-z0-9\.]*:\([0-9]*\)/\2/')

		if is_mac; then
			# nc on Mac needs -G for the connections timeout argument.
			nc -z -G 1 $host $port 2>/dev/null 1>/dev/null
		else		
			nc -z -w 1 $host $port 2>/dev/null 1>/dev/null
		fi
	fi

	return $?
}

# Check whether shell is interactive
# Otherwise we are running in a non-interactive script environment
is_tty ()
{
	# Override option via $DRUDE_IS_TTY (true|false) env variable.
	if [[ $DRUDE_IS_TTY == 1 ]]; then
		return 0;
	fi
	if [[ $DRUDE_IS_TTY == 0 ]]; then
		return 1;
	fi

	[[ "$(/usr/bin/tty || true)" != "not a tty" ]]
}

#---------------------------- Other helper functions -------------------------------

testing_warn ()
{
	if ! is_tty; then return; fi
	if [[ ! $B2D_BRANCH == 'master' ]] || [[ ! $DRUDE_BRANCH == 'master' ]]; then
		echo-yellow "dsh: boot2docker - ${B2D_BRANCH}, drude - ${DRUDE_BRANCH}"
	fi
}

# Convert version string like 1.2.3 to integer for comparison
# param $1 version string of 3 components max (e.g. 1.10.3)
ver_to_int ()
{
	printf "%03d%03d%03d" $(echo "$1" | tr '.' ' ')
}

#---------------------------- Control functions -------------------------------

check_dsh_environment ()
{
	check_docker_running
	check_yml
}

check_docker_running ()
{
	check_binary_found 'docker'
	check_binary_found 'docker-compose'
	if ! is_docker_running; then
		local msg="dsh: Unable to connect to the Docker daemon"
		if [ ! -z "$DOCKER_HOST" ]; then
			msg="$msg via '$DOCKER_HOST'"
		fi
		echo-red "$msg"
		
		if is_docker_beta; then
			echo-red "Make sure the Docker Beta app is running"
		elif is_mac || is_windows; then
			echo-red "Drude VM may not be running. It can be started with 'dsh up'"
			_confirm "Run 'dsh up' now?"
			up
			if_failed "Could not start the VM properly"
		fi

		exit 1
	fi
}

# Check that docker-compose.yml (and Vagrantfile on Win/Mac) present. Fail otherwise
check_yml()
{
	yml_path=$(get_yml_path)
	if [[ "$yml_path" == "" ]] ; then
		echo-red "dsh: docker-compose.yml was not found in your directory tree"
		exit 1
	fi

	if is_linux || is_docker_beta; then
		return; # linux does not need vagrant
	fi

	vagrant_path=$(upfind "Vagrantfile")
	if [[ "$vagrant_path" == "" ]] ; then
		echo-red "dsh: Vagrantfile was not found in your directory tree"
		exit 1
	fi
}

# Check that command is run inside project folder
check_drush_path ()
{
	local pathdiff=$(get_current_relative_path)
	if [[ "$(pwd)" == "$pathdiff" ]]; then
		echo-red "dsh: This command must be run inside Drupal's document root"
		exit 1
	fi
}

# Yes/no confirmation dialog with an optional message
# @param $1 confirmation message
_confirm ()
{
	# Skip checks if not running interactively (not a tty or not on Windows)
	if ! is_tty; then return 0; fi

	while true; do
		read -p "$1 [y/n]: " answer
		case $answer in
			[Yy]|[Yy][Ee][Ss] )
				break
				;;
			[Nn]|[Nn][Oo] )
				exit 1
				;;
			* )
				echo 'Please answer yes or no.'
		esac
	done
}

# Display desktop notification (Mac only)
# @param $1 title
# @param $2 message
_notify ()
{
	if is_mac && [[ "$1" != "" ]]; then
		osascript -e 'display notification "'"$2"'" with title "'"$1"'"'
	fi
}

# Make sure $DOCKER_HOST is not empty
check_docker_host ()
{
	if is_linux ; then return 0; fi
	# don't change DOCKER_HOST if it's nonempty
	if [[ "$DOCKER_HOST" != "" ]]; then
		return 0;
	else
		# set Drude's default DOCKER_HOST var
		DOCKER_HOST=$DEFAULT_DOCKER_HOST
		export DOCKER_HOST=$DEFAULT_DOCKER_HOST
	fi
}
check_docker_host #perform this check in any case

#-------------------------- Containers management -----------------------------

_start_containers ()
{
	ssh_add
	echo-green "Starting services..."
	docker_compose up -d && \
		_vhost_proxy_connect && \
		_set_cli_uid
}

# @param $1 container_name
_restart_containers ()
{
	echo-green "Restarting services..."
	docker_compose restart $* && \
		_vhost_proxy_connect && \
		_set_cli_uid
}

# @param $1 "-a" || "--all"
_stop_containers ()
{
	echo-yellow "Stopping services..."
	if [[ $1 == '-a' ]] || [[ $1 == '--all' ]]; then
		# stop all but system containers (--label "group=system")
		docker ps --format '{{.ID}} {{.Label "group"}}' | grep -v 'system' | xargs docker stop
	fi
	if [[ "$1" == "proxy" ]] ; then
		echo-green 'Stopping Drude HTTP/HTTPS reverse proxy service...'
		docker stop vhost-proxy
		return
	fi

	if [[ "$1" == "dns" ]] ; then
		echo-green 'Stopping Drude DNS service...'
		docker stop dns
		return
	fi

	if [[ "$1" == "ssh-agent" ]] ; then
		echo-green 'Stopping Drude ssh-agent service...'
		docker stop ssh-agent
		return
	fi
	docker_compose stop
}

# @param $1 container_name
_remove_containers ()
{
	if [[ $1 == "" ]]; then
		echo-yellow "Removing containers..."
	fi
	docker_compose kill $* && docker_compose rm -vaf $*
}

_docker_cleanup ()
{
	if [[ "$1" == "--hard" ]] && [[ "$(docker ps -aqf status=exited)" != "" ]]; then
		echo -e "${red}WARNING: ${yellow}Preparing to delete all currently stopped containers:${NC}"
		docker ps -af status=exited --format "{{.Label \"com.docker.compose.project\"}}_{{.Label \"com.docker.compose.service\"}}\t\t{{.Status}} ({{.Image}})"
		printf '–%.0s' $(seq 1 40)
		echo -e "${yellow}"
		_confirm "Continue?"
		echo -e "${NC}"
		#--
		echo-green "Removing stopped containers..."
		docker ps -aqf status=exited | xargs docker rm -vf
	fi

	echo-green "Cleaning up images..."
	docker images -qf dangling=true | xargs docker rmi 2>1
}

# Connect vhost-proxy to all bridge networks on the host
_vhost_proxy_connect ()
{
	echo-green "Connecting vhost-proxy to networks..."
	docker network ls -q --filter name=_default | while read network; do 
		docker network connect $network vhost-proxy >/dev/null 2>&1 || true
	done
}

#------------------------------ Help functions --------------------------------

# Show help for dsh or for certain command
# $1 name of command to show help for
show_help ()
{
	local commands_path="$(get_drude_path)/$DRUDE_COMMANDS_PATH"
	local custom_commands_list

	echo "Drude Shell $DSH_VERSION help."

	# Show help for certain command
	if [[ ! -z "$1" ]]; then
		# Check for help function for specific command
		type "show_help_$1" 1>/dev/null 2>/dev/null
		if [ $? -eq 0 ]; then
			show_help_$1
			exit
		fi
		# Check for custom command file
		if [ -f "$commands_path/$1" ]; then
			echo -en "${green}dsh $1${NC} - "
			cat "$commands_path/$1" | grep '^##' | sed "s/^##[ ]*//g"
			echo
			exit
		fi
	fi

	echo
	if is_linux; then
		echo "	start (up)		Start project services (containers)"
	else
		echo "	start (up)		Start vagrant vm (if stopped) and project services (containers)"
	fi
	echo "	stop (down)		Stop project services (containers)"
	echo "	    -a (--all)		Stop all running containers from all Docker projects (except where group=system)"
	echo "	restart	[service]	Restart all current project services (containers) or specified service"
	if ! is_linux; then
		echo "	reload			Restart vagrant vm"
		echo "	halt			Stop vagrant vm"
	fi
	echo "	status (st, ps)		Show project services (containers) status"
	echo "	    -a (--all)		Show status of all running containers from all Docker projects"
	echo "	reset [service]		Recreate service(s). If no parameter given recreates all project services."
	echo "	    See 'dsh help reset' for more details on resetting Drude system services."
	echo "	remove [service]	Remove project services (containers). If no parameter given removes all project services"
	echo
	echo "	bash [service]		Open bash to service (container). If no service specified defaults to 'cli'"
	echo "	exec (run) <command>	Execute a command in 'cli' container (Usage: dsh exec <command> [params])"
	echo "	logs [service]		Show docker logs for service (container)"
	echo
	echo "	exec-url <url>		Download script from URL and run it. URL should be public."
	echo
	echo "	drush [command]		Execute Drush command (usage: dsh drush [command] [option] [option]...)"
	echo "	cc [cache_type]		Clear Drupal 7 caches (\"dsh cc\" is equal to \"dsh cc all\")"
	echo "	drupal [command]	Execute Drupal Console command (Drupal 8)"
	echo
	echo "	mysql (sqlc)		Opens mysql shell to current project database"
	echo "	mysql-import <file>	Truncate database and import from sql dump (usage: dsh mysql-import <dbdump.sql|dbdump.sql.gz>)"
	echo "	    (sqli)		Note: DB dump file should be inside your project folder"
	echo
	echo "	behat [--path=path]	Run Behat tests from path (relative to project root). Default: tests/behat"
	echo
	echo "	ssh-add [-lD] [key]	Adds private key identities to the authentication agent. See 'dsh help ssh-add'"
	echo
	if is_linux; then
		echo "	install			Install/check prerequisites and drude config"
	else
		echo "	install			Install/check prerequisites, boot2docker and drude config"
	fi
	echo "	install prerequisites 	Only install prerequisites"
	if ! is_linux; then
		echo "	install boot2docker 	Only install boot2docker"
	fi
	echo "	install drude-config 	Only install the latest default docker-compose.yml"
	echo "	install autocomplete 	Install commands autocomplete for Bash"
	echo
	echo "	update prerequisites 	Update prerequisites"
	if ! is_linux; then
		echo "	update boot2docker	Update boot2docker-vagrant box"
	fi
	echo "	update images		Update container images"
	echo "	update dsh		Update dsh itself (ex. dsh self-update)"
	echo
	echo "	cleanup			Cleanup images to save space (--hard to clean up containers)"
	echo "	system-information	(sysinfo) Show diagnostics information for bug reporting"
	if ! is_linux; then
		echo "	vmstat			Show vagrant vm usage statistics"
	fi
	echo "	version	(v, -v)		Print dsh version. [v, -v] - prints short version"

	# Show list of custom commands and their help if available
	if [ ! -z "$(get_drude_path)" ]; then
		custom_commands_list=$(ls "$commands_path" 2>/dev/null | tr "\n" " ")
		if [ ! -z "$custom_commands_list" ]; then
			echo
			echo -e "Custom commands found in ${yellow}$DRUDE_COMMANDS_PATH${NC}:";
			for cmd_name in $custom_commands_list
			do
				# command description is lines that start with ##
				local cmd_desc=$(cat "$commands_path/$cmd_name" | grep '^##' | sed "s/^##[ ]*//g" | head -1 --)
				printf "\t%-23s" $cmd_name
				echo "	$cmd_desc"
			done
		fi
	fi

	echo
}

show_help_ssh-add ()
{
	echo-green "dsh ssh-add - Add private key identities to the ssh-agent."
	echo "Usage: dsh ssh-add [-lD] [key]"
	echo
	echo "When run without arguments, picks up the default key file (~/.ssh/id_rsa or ~/.ssh/id_dsa)."
	echo "A custom key name can be given as an argument: dsh ssh-add <keyname>."
	echo 
	echo -e "${yellow}NOTE${NC}: <keyname> is the file name (not full path) within ${yellow}~/.ssh${NC}."
	echo "Example: dsh ssh-add my_custom_key_rsa"
	echo
	echo "The options are as follows:"
	echo "	-D      Deletes all identities from the agent."
	echo "	-l      Lists fingerprints of all identities currently represented by the agent."
	echo
}

show_help_reset ()
{
	echo-green "dsh reset -  Recreate services/containers. Equal to dsh stop, dsh remove, dsh start"
	echo
	echo-green "Parameters: one or more service names. Examples:"
	echo "	dsh reset web		Restart 'web' service"
	echo "	dsh reset web cli	Restart 'web' and 'cli' services"
	echo "	dsh reset		Restart all project services"
	echo
	echo-green "System services"
	echo -e "Drude has 3 system services."
	echo -e "Names ${yellow}'dns'${NC}, ${yellow}'proxy'${NC}, ${yellow}'ssh-agent'${NC} and ${yellow}'system'${NC} are reserved and are not recommended for use."
	echo "	dsh reset dns		Recreate Drude DNS service"
	echo -e "	dsh reset proxy		Recreate Drude HTTP/HTTPS reverse proxy service (resolves ${yellow}*.drude${NC} domain names into container IPs)"
	echo "	dsh reset ssh-agent	Recreate Drude ssh-agent service"
	echo "	dsh reset system	Recreate all Drude system services"
	echo
}

# Display dsh version
# @option --short - Display only the version number
version ()
{
	if [[ $1 == '--short' ]]; then
		echo "$DSH_VERSION"
	else
		testing_warn
		echo "dsh version: $DSH_VERSION"
	fi
}

# return bash completion words
# @param $1 command to return words for
bash_comp_words ()
{
	case $1 in
		install)
			echo "prerequisites boot2docker drude-config"
			exit 0
			;;
		update)
			echo "prerequisites boot2docker images dsh"
			exit 0
			;;
		dsh)
			echo "start up stop down halt reload restart status vmstat reset remove bash exec logs run mysql sqlc mysql-import sqli exec-url drush drupal behat install update self-update version help"
			exit 0
			;;
		*)
			exit 1 #return 1 to completion function to prevent completion is we don't know what to do
	esac
}

#------------------------------- User Commands -----------------------------------
# Start containers
up ()
{
	check_yml
	if is_linux || is_boot2docker || is_docker_beta; then
		_start_containers
	else
		check_binary_found 'vagrant'
		local started
		if ! is_docker_running; then
			echo-green "dsh: Starting vagrant vm..."
			vagrant up
			started=$?
		else
			started=0
		fi
		if [ $started -eq 0 ] ; then
			_start_containers
		fi
	fi
}

# Stop containers
down ()
{
	check_dsh_environment
	_stop_containers "$@"
}

# Stop Vagrant box
halt ()
{
	check_dsh_environment
	if is_linux || is_boot2docker; then
		_stop_containers
	else
		vagrant halt
	fi
}

# Restart container(s)
# @param $1 container_name
restart ()
{
	check_dsh_environment
	_restart_containers $*
}

# Restart Vagrant and start containers again
reload ()
{
	check_yml
	if is_linux || is_boot2docker || is_docker_beta; then
		_start_containers
	else
		check_binary_found 'vagrant'
		echo-green "dsh: Restarting vagrant vm..."
		vagrant reload
		if [ $? -eq 0 ]; then
			_start_containers
		fi
	fi
}

# output status of Drude if stopped or containers if started
# @param $1 Show containers from all projects (-a)
status ()
{
	check_dsh_environment

	if [[ "$1" == "-a" ]] || [[ "$1" == "--all" ]]; then
		docker ps
	else
		docker_compose ps
	fi
}

vmstat ()
{
	local vagrant_path=$(upfind Vagrantfile)
	if [[ $vagrant_path == "" ]]; then
		echo-red "dsh: Vagrantfile was not found in your directory tree"
		exit 1
	fi
	check_binary_found vboxmanage
	local machine_id="${vagrant_path}/.vagrant/machines/boot2docker/virtualbox/id"
	if [ ! -f $machine_id ]; then
		echo-red "Could not find id file $machine_id"
		exit 1
	fi
	local id=$(cat $machine_id)
	metrics="CPU/Load/User,CPU/Load/Kernel,Disk/Usage/Used,RAM/Usage/Used,Net/Rate/Rx,Net/Rate/Tx"
	vboxmanage metrics setup --period 1 --samples 1 "$id"
	sleep 1
	vboxmanage metrics query "$id" $metrics
}

# Add key to ssh-agent or run ssh-add with provided @param
# @param $1 -D, -l or path to custom key
ssh_add () {
	# Check if ssh-agent container is running
	local running=$(docker inspect --format="{{ .State.Running }}" ssh-agent 2> /dev/null)
	if [ $? -eq 0 ] && [ "$running" == "true" ]; then

		local ssh_path="$HOME/.ssh"
		# Home folder mount in boot2docker
		if ! is_linux; then
			ssh_path="/.home/.ssh"
		fi
		local key_path=""

		case "$1" in
			"")
				if docker exec -it ssh-agent ssh-add -l > /dev/null; then
					return; # Some key is present
				fi
				;;
			-D) 
				docker run --rm --volumes-from=ssh-agent -it "blinkreaction/ssh-agent:${DRUDE_ITAG}" ssh-add -D
				exit 1
				;;
			-l) 
				# We do a sed hack here to strip out '/root/.ssh' from the key path in the output from ssh-add, since this path may confuse people.
				docker run --rm --volumes-from=ssh-agent -it "blinkreaction/ssh-agent:${DRUDE_ITAG}" ssh-add -l 2>&1 | sed 's/\/root\/.ssh\///g'
				exit 1
				;;
			*) 
				key_path="/root/.ssh/$1"
				# We check $HOME here regardless Linux or Mac/Windows (boot2docker)
				# $HOME is mounted as /.home in boot2docker
				if [ ! -f "$HOME/.ssh/$1" ]; then
					echo-red "SSH key file not found: $HOME/.ssh/$1"
					exit 1
				fi
				;;
		esac
		
		echo "Press ENTER or CTRL+C to skip entering passphrase."
		# $ssh_path is mounted as /root/.ssh in the ssh-agent containers.
		# When $key_path is empty, ssh-agent will be looking for both id_rsa and id_dsa in the home directory.
		# We do a sed hack here to strip out '/root/.ssh' from the key path in the output from ssh-add, since this path may confuse people.
		docker run --rm --volumes-from=ssh-agent -it -v "$ssh_path:/root/.ssh" "blinkreaction/ssh-agent:${DRUDE_ITAG}" ssh-add "$key_path" 2>&1 | sed 's/\/root\/.ssh\///g'
	fi
}

#----- Installations and updates -----

# Install required software on Mac or Win. Check installed software on Linux
install_prerequisites ()
{
	testing_warn
	if is_docker_running; then
		if is_linux; then
			stopcmd="'dsh stop'"
		else
			stopcmd="'dsh halt'"
		fi
		echo-yellow "WARNING: Docker is running. It's recommended to stop Docker first with ${stopcmd} "
		_confirm "Stop Docker now?"
		
		if is_linux || is_boot2docker; then
			_stop_containers
		else
			vagrant halt
		fi
	fi

	echo-green "Installing prerequisites..."

	if is_windows ; then
		# installing prerequisites
		local presetup_script
		presetup_script=$(curl -fsS https://raw.githubusercontent.com/blinkreaction/boot2docker-vagrant/$B2D_BRANCH/scripts/presetup-win.sh)
		if_failed "Could not get 'presetup-win.sh'. Please check your internet connection"
		bash <(echo "$presetup_script")
		read -p "Press enter after the installation in another console window is done..."
	elif is_linux ; then
		install_ubuntu
	else # mac
		local presetup_script
		presetup_script=$(curl -fsS https://raw.githubusercontent.com/blinkreaction/boot2docker-vagrant/$B2D_BRANCH/scripts/presetup-mac.sh)
		if_failed "Could not get 'presetup-mac.sh'. Please check your internet connection"
		bash <(echo "$presetup_script")
	fi
}

install_proxy_service ()
{
	docker rm -f vhost-proxy >/dev/null 2>&1 || true
	docker run -d --name vhost-proxy --label "group=system" --restart=always --privileged --userns=host \
		-p 80:80 -p 443:443 \
		-v /var/run/docker.sock:/tmp/docker.sock \
		"blinkreaction/nginx-proxy:${DRUDE_ITAG}" >/dev/null 2>&1
}

install_dns_service ()
{
	# Use default DNS on Linux and VirtualBox's buit-in DNS if using boot2docker
	local dns
	if is_linux; then dns=$DRUDE_DEFAULT_DNS; else dns=$DRUDE_VBOX_DNS; fi

	# Support for boot2docker-vagrant
	local docker_ip_map="-p 172.17.42.1:53:53/udp"
	if is_linux; then docker_ip_map=""; fi
	   
	docker rm -f dns >/dev/null 2>&1 || true
	docker run -d --name dns --label "group=system" --restart=always --privileged --userns=host \
		-p $DRUDE_IP:53:53/udp $docker_ip_map --cap-add=NET_ADMIN --dns $dns \
		-v /var/run/docker.sock:/var/run/docker.sock \
		"blinkreaction/dns-discovery:${DRUDE_ITAG}" >/dev/null 2>&1
}

install_sshagent_service ()
{
	docker rm -f ssh-agent >/dev/null 2>&1 || true
	docker run -d --name ssh-agent --label "group=system" --restart=always --privileged --userns=host \
		-v /var/run/docker.sock:/var/run/docker.sock \
		"blinkreaction/ssh-agent:${DRUDE_ITAG}" >/dev/null 2>&1
}

# Install Docker and setup Drude on Ubuntu 14.04+
install_ubuntu ()
{
	if [ -r /etc/lsb-release ]; then
		lsb_dist="$(. /etc/lsb-release && echo "$DISTRIB_ID")"
		lsb_release="$(. /etc/lsb-release && echo "$DISTRIB_RELEASE")"
	fi

	if [[ $lsb_dist != 'Ubuntu' || $(ver_to_int $lsb_release) < $(ver_to_int '14.04') ]]; then
		echo-red "dsh: prerequisites installation is currently supported only on Ubuntu 14.04+"
		if is_tty; then
			echo-yellow "You can continue at your own risk, if you know your Linux distribution is compatible with Ubuntu 14.04+"
			_confirm "Are you sure you want to continue?"
		else
			exit 1
		fi
	fi

	echo-green "Installing Docker..."
	sudo service docker stop && \
		curl -sSL https://get.docker.com/ | sh && \
		sudo usermod -aG docker $(whoami)
	sudo docker version
	if_failed "Docker installation/upgrade has failed."

	echo-green "Installing Docker Compose..."
	sudo curl -L https://github.com/docker/compose/releases/download/1.7.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose && \
	sudo chmod +x /usr/local/bin/docker-compose && \
	docker-compose --version
	if_failed "Docker Compose installation/upgrade has failed."

	echo-green "Adding a subnet for Drude..."
	# Make sure we don't do this twice
	if ! grep -q $DRUDE_SUBNET /etc/network/interfaces; then
		cat > /tmp/drude.ip.addr <<EOF
	up   ip addr add $DRUDE_SUBNET dev lo label lo:drude
	down ip addr del $DRUDE_SUBNET dev lo label lo:drude
EOF
		sudo sed -i '/iface lo inet loopback/r /tmp/drude.ip.addr' /etc/network/interfaces
		rm -f /tmp/drude.ip.addr
		sudo ifdown lo && sudo ifup lo
		if_failed "Docker subnet configuration failed failed."
	fi

	echo-green "Creating Drude HTTP/HTTPS reverse proxy..."
	install_proxy_service
	if_failed "Drude HTTP/HTTPS reverse proxy setup failed."

	echo-green "Creating Drude DNS service..."
	install_dns_service
	if_failed "Drude DNS service setup failed."

	echo-green "Creating Drude ssh-agent service..."
	install_sshagent_service
	if_failed "Drude ssh-agent service setup failed."

	echo-green "Configuring host DNS resolver for .drude domain..."
	echo -e "\n# .drude domain resolution\nnameserver $DRUDE_IP" | sudo tee -a  /etc/resolvconf/resolv.conf.d/head
	sudo resolvconf -u

	echo-green "To run docker without sudo please re-login or run 'newgrp docker' now."
}

# Install Vagrantfile and vagrant.yml required by boot2docker
install_boot2docker ()
{
	testing_warn
	if is_linux ; then
		return 0; # not needed on Linux
	fi
	echo-green "Downloading boot2docker install script..."

	if is_windows ; then
		curl -fsS https://raw.githubusercontent.com/blinkreaction/boot2docker-vagrant/$B2D_BRANCH/scripts/setup.sh -o ~/setup.sh
	else
		local b2d_setup_script
		b2d_setup_script=$(curl -fsS https://raw.githubusercontent.com/blinkreaction/boot2docker-vagrant/$B2D_BRANCH/scripts/setup.sh)
	fi
	if_failed "Could not get 'setup.sh'. Please check your internet connection"

	echo "done"
	echo-yellow "Running boot2docker install script..."
	if is_windows ; then
		chmod +x ~/setup.sh
		B2D_NO_AUTOSTART=1 ~/setup.sh
	else
		# calling bash interactively. B2D_NO_AUTOSTART prevents vagrant up after download
		B2D_NO_AUTOSTART=1 bash <(echo "$b2d_setup_script")

		# Configuring resolver
		echo-yellow "Configuring *.drude wildcard DNS resolution..."
		sudo mkdir -p /etc/resolver
		echo -e "\n# .drude domain resolution\nnameserver $DRUDE_IP" | sudo tee 1>/dev/null /etc/resolver/drude
	fi
}

# Download latest Drude config file
install_drude_config ()
{
	testing_warn
	local docker_compose_yml
	docker_compose_yml=$(curl -kfsS "https://raw.githubusercontent.com/blinkreaction/drude/$DRUDE_BRANCH/docker-compose.yml")
	if_failed  "Could not get latest docker-compose.yml version."

	echo "$docker_compose_yml" | tee "docker-compose.yml" >/dev/null
	if_failed  "Could not write to docker-compose.yml"
	echo-green "Latest version of docker-compose.yml was downloaded."
}

# Install shell commands autocomplete script
install_autocomplete ()
{
	local autocomplete_script
	autocomplete_script=$(curl -kfsS "https://raw.githubusercontent.com/blinkreaction/drude/$DRUDE_BRANCH/bin/dsh-bash-complete")
	if_failed "Autocomplete script download has failed"

	destination="/usr/local/bin/dsh-bash-autocomplete"
	echo "$autocomplete_script" | tee "$destination" >/dev/null
	if_failed "Failed to write file to $destination"
	echo-green "Script saved to $destination"
	chmod +x $destination

	SOURCE_FILE=".bash_profile"
	grep -q "$destination" $HOME/$SOURCE_FILE
	if [[ $? -ne 0 ]]; then
		echo -e ". $destination" >> $HOME/$SOURCE_FILE
		if_failed "Failed to write file to $HOME/$SOURCE_FILE"
		echo-green "Autocomplete appended to $HOME/$SOURCE_FILE"
		echo-yellow "dsh: Please restart your bash session to apply"
	fi
}

# Install everything: prerequisites, boot2docker and drude config
install ()
{
	if [[ "$1" == "prerequisites" ]]; then
		install_prerequisites
	elif [[ "$1" == "boot2docker" ]]; then
		echo -e "${green}ATTENTION:${NC} Vagrantfile and vagrant.yml will be downloaded to ${green}$(pwd)${NC}"
		echo -e "           If that is not correct please cancel, cd to proper dir and re-run command."
		_confirm "Continue with download to $(pwd)?"
		install_boot2docker
	elif [[ "$1" == "drude-config" ]]; then
		install_drude_config
	elif [[ "$1" == "autocomplete" ]]; then
		install_autocomplete
	else # Full setup
		local cwd=$(pwd)
		install_prerequisites
		if ! is_linux ; then
			cd ..
			_confirm "Install Vagrantfile to $(pwd) (This should be your <Projects> folder)?"
			install_boot2docker
			cd $cwd
		fi
		_confirm "Install default docker-compose.yml to $(pwd) (This should be your <drupal_site> folder)?"
		install_drude_config
		echo-green "Please restart you terminal shell to pick up DOCKER_HOST environment variable and then use 'dsh up' to start Drude"
	fi
}

# Update container images
update_images ()
{
	check_dsh_environment
	docker pull "blinkreaction/nginx-proxy:${DRUDE_ITAG}"
	docker pull "blinkreaction/dns-discovery:${DRUDE_ITAG}"
	docker pull "blinkreaction/ssh-agent:${DRUDE_ITAG}"
	docker_compose pull
	echo-green "Resetting system services..."
	reset system
	up
}

# Update Vagrant Box
update_boot2docker ()
{
	testing_warn
	if ! is_tty; then
		echo-red "dsh: update is not allowed in a non-interactive environment."
		return 1
	fi

	if ! is_windows && ! is_mac ; then
		echo-red "dsh: drude boot2docker box update should be used on Mac and Win only"
		return 1
	fi

	# don't download update if we can't locate Vagrantfile
	vagrant_path=$(upfind "Vagrantfile")
	if [[ "$vagrant_path" == "" ]] ; then
		echo-red "dsh: Vagrantfile not found in your directory tree"
		return 1
	fi

	local cwd=$(pwd)
	echo-green "Installing boot2docker update..."

	# get current version
	local b2d_version=$(cat $DRUDE_B2D_VERSION 2>/dev/null)
	if [[ "$b2d_version" = "" ]]; then b2d_version="undetected version"; fi

	# get new version
	local b2d_new_version
	b2d_new_version=$(curl -kfsS https://raw.githubusercontent.com/blinkreaction/boot2docker-vagrant/$B2D_BRANCH/VERSION)
	if_failed "Could not get latest boot2docker version. Please check your internet connection"

	# update boot2docker
	local forced_update='';
	local destroy_box=1;
	if [[ "$1" == "-f" ]] || [[ "$2" == "-f" ]]; then forced_update="(forced update)"; fi
	if [[ "$1" == "-n" ]] || [[ "$2" == "-n" ]]; then destroy_box=0; fi

	if [[ ! "$b2d_new_version" == "$b2d_version" ]] || [ -n "$forced_update" ]; then
		echo -e "boot2docker update available: ${green}$b2d_new_version $forced_update${NC} (you have $b2d_version)."
		if [ $destroy_box -eq 1 ]; then
			echo -e "${red}Update will destroy and re-create your Vagrant box${NC} (run with -n if you know re-creation can be skipped this time)"
			_confirm "Please confirm."
		else
			echo-green "Vagrant box will not be re-created"
		fi

		cd $vagrant_path
		echo "Vagrantfile is found in "$(pwd)

		echo-green "dsh: Downloading boot2docker install script..."
		local b2d_setup_script
		b2d_setup_script=$(curl -kfsS https://raw.githubusercontent.com/blinkreaction/boot2docker-vagrant/$B2D_BRANCH/scripts/setup.sh)
		if_failed  "Could not get latest boot2docker version. Please check your internet connection"

		echo "dsh: Creating backups in $DRUDE_CONFIG_BACKUP_DIR..."
		local timestamp=$(date +%s)
		cp -v Vagrantfile $DRUDE_CONFIG_BACKUP_DIR/Vagrantfile.$timestamp && \
		cp -v vagrant.yml $DRUDE_CONFIG_BACKUP_DIR/vagrant.yml.$timestamp
		if_failed "Unable to perform configuration backups. Aborting..."
		# contingency. remove old backups
		rm "$DRUDE_CONFIG_DIR/Vagrantfile.*" 2>/dev/null
		rm "$DRUDE_CONFIG_DIR/vagrant.yml.*" 2>/dev/null

		if [ $destroy_box -eq 1 ]; then
			echo-yellow "dsh: Destroying vagrant box..."
			vagrant destroy -f
		fi

		echo-green "dsh: Running boot2docker install script..."
		# calling bash interactively
		bash <(echo "$b2d_setup_script")

		if_failed "boot2docker install script error"

		# update recorded boot2docker version
		echo $b2d_new_version > $DRUDE_B2D_VERSION
		echo -e "boot2docker ${green}$b2d_new_version${NC} was installed"
	else
		echo "boot2docker $b2d_version you have is the latest version (-f to force update)"
	fi

	cd $cwd # go back where we were
}

# Update dsh itself
update_dsh ()
{
	testing_warn
	echo "Downloading..."
	local new_dsh
	new_dsh=$(curl -kfsS "https://raw.githubusercontent.com/blinkreaction/drude/$DRUDE_BRANCH/bin/dsh")
	if_failed "Download has failed."

	# Check if update is a major version. Show warning is needed
	local new_version=$(echo "$new_dsh" | grep "^DSH_VERSION=" | cut -f 2 -d "=")
	local current_major_version=$(echo $DSH_VERSION | cut -d "." -f 1)
	local new_major_version=$(echo $new_version | cut -d "." -f 1)
	if [[ "$current_major_version" != "$new_major_version" ]]; then
		echo -e "${red_bg} WARNING ${NC} ${red}Non-backwards compatible version update${NC}"
		echo -e "Updating from ${yellow}$DSH_VERSION${NC} to ${yellow}$new_version${NC} is a non-backwards compatible update."
		echo "You might be not able to use you current Drude environment if you proceed."
		echo -e "Please read update documentation: ${yellow}https://github.com/blinkreaction/drude#updates${NC}"
		_confirm "Continue with update?"
	fi

	# saving to file
	echo "$new_dsh" | sudo tee /usr/local/bin/dsh > /dev/null
	if_failed "Could not write /usr/local/bin/dsh."
	sudo chmod +x /usr/local/bin/dsh

	local new_version=$(head /usr/local/bin/dsh | grep "^DSH_VERSION=" | cut -f 2 -d "=")
	echo-green "dsh updated to ${new_version}"
	exit
}

check_for_updates ()
{
	# Never trigger in scripts
	if ! is_tty; then return; fi

	local timestamp; local last_check; local next_check
	timestamp=$(date +%s)
	last_check=$(cat $DRUDE_LAST_CHECK 2>/dev/null)
	# Set last_check to 0 if empty
	last_check="${last_check:-0}"
	# Check once a week
	next_check=$(($last_check+604800))
	if [ $timestamp -le $next_check ]; then
		return;
	fi

	echo 'dsh: checking for updates...'
	local new_dsh; local new_version
	# Always write current timestamp to last check file
	echo $timestamp > $DRUDE_LAST_CHECK
	# No -S for curl here to be completely silent. Connection timeout 1 sec, total max time 3 sec or fail
	new_dsh=$(curl -kfs --connect-timeout 1 --max-time 3 https://raw.githubusercontent.com/blinkreaction/drude/$DRUDE_BRANCH/bin/dsh)
	new_version=$(echo "$new_dsh" | grep "^DSH_VERSION=" | cut -f 2 -d "=")
	if [ $(ver_to_int $new_version) -gt $(ver_to_int $DSH_VERSION) ]; then
		echo-green-bg " UPDATE AVAILABLE "
		echo -e "${green}dsh${NC} [ $DSH_VERSION --> $new_version ] (run ${green}dsh update dsh${NC} to update)"
		echo "Press enter to continue with your command."
		read -p ''
	fi
}

#-------------------------- Execution commands -----------------------------

# Start an interactive bash session in a container
# @param $1 container name
_bash ()
{
	# Interactive shell requires a tty.
	# On Windows we assume we run interactively via winpty (console.exe).
	if ! is_tty; then
		echo "Interactive bash console in a non-interactive enveronment!? Nope, won't happen."
		return 1
	fi

	# Pass container name to _run
	CONTAINER_NAME=$1 _run bash -i
}

# Run a command in the cli container changing dir to the same folder
# @param $* command with it's params to run
_run ()
{
	check_dsh_environment

	if [[ "$CONTAINER_NAME" == "" ]]; then CONTAINER_NAME='cli'; fi
	container_id=$(get_container_id $CONTAINER_NAME)

	# 1) $winpty_cmd
	local winpty_cmd
	# Running docker exec interactively on Windows requires workarounds
	if is_windows; then
		# Workaround - run docker exec via winpty (console.exe) to get a tty console in cygwin.
		if is_binary_found 'console'; then
			winpty_cmd='console'
		elif is_binary_found 'winpty'; then
			winpty_cmd='winpty'
		else
			echo-red 'Winpty binary is missing.'
			echo 'Run "dsh install prerequisites" to install it.'
			exit 1
		fi
	fi

	# 2) cmd
	local cmd

	local cdir
	# Only chdir to the same dir in cli container
	# RUN_NO_CDIR can be used to override this (used in mysql_import)
	if [[ $CONTAINER_NAME == "cli" ]] && [[ $RUN_NO_CDIR != 1 ]]; then
		local path
		path=$(get_current_relative_path)
		if [[ "$path" != "$(pwd)" ]] && [[ "$path" != "" ]] ; then
			# we're inside docroot
			cdir="cd $path &&"
		fi
		if [[ "$path" == "" ]] ; then
			# we're on project folder level (outside docroot)
			cdir="cd docroot &&"
		fi
	fi

	local columns
	if is_tty ; then
		columns="export COLUMNS=$(tput cols) &&"
	fi

	cmd="$cdir $columns"

	# 3) convert array of parameters into escaped string
	# Escape spaces that are "spaces" and not parameter delimeters (i.e. param1 param2\ with\ spaces param3)
	if [[ $2 != "" ]]; then
		cmd="$cmd "$(printf " %q" "$@")
	# Do not escape spaces if there is only one parameter (e.g. dsh run "ls -la | grep txt")
	else
		cmd="$cmd $@"
	fi
	
	# 4) execute
	if is_tty ; then
		# interactive
		if [[ $1 == "" ]]; then
			$winpty_cmd docker exec -it $container_id bash -i
		else
			$winpty_cmd docker exec -it $container_id bash -ic "$cmd"
		fi
	else
		# non-interactive
		docker exec $container_id bash -c "$cmd"
	fi
}

# start interactive mysql shell
mysql ()
{
	check_dsh_environment
	check_drush_path
	_run $(get_mysql_connect)" -A" # -A option to speed up mysql load
}

# Truncate db and import from sql dump
# @param $1 filename of backup file. Should be inside project root
mysql_import ()
{
	check_dsh_environment
	check_drush_path

	local confirm=1
	if [[ "$1" == "-y" ]] || [[ "$2" == "-y" ]]; then
		confirm=0
		if [[ "$1" == "-y" ]]; then
			shift #remove this param if -y was first
		fi
	fi

	project_root=$(get_yml_path)
	local filename=$(basename $1)
	local filepath=$(get_abs_path $1)
	#substract project root path from filepath
	local pathdiff=${filepath#$project_root}

	if [[ $pathdiff == $filepath ]] ; then
		# substraction did not succeed because file is outside project root
		echo "\"$filename\" should be inside your project root folder"
		return
	fi

	if [ $confirm -eq 1 ]; then
		_confirm "[!] This will drop the existing database. Continue?"
	fi

	#_run drush sql-drop -y
	local sql_connect
	sql_connect=$(get_mysql_connect)
	echo "Importing $filename into the database..."

	# Use pv for interactive shells only.
	if is_tty ; then
		# Check if we have a gzipped dump and treat it differently.
		if [[ $filename == *.gz ]]; then
			file_size=$(gzip -l $1 | sed -n 2p | awk '{print $2}')
			RUN_NO_CDIR=1 _run "zcat ./$pathdiff/$filename | pv --size $file_size | $sql_connect"
		else
			RUN_NO_CDIR=1 _run "pv ./$pathdiff/$filename | $sql_connect"
		fi
	else
		# Check if we have a gzipped dump and treat it differently.
		if [[ $filename == *.gz ]]; then
			RUN_NO_CDIR=1 _run "zcat ./$pathdiff/$filename | $sql_connect"
		else
			RUN_NO_CDIR=1 _run "cat ./$pathdiff/$filename | $sql_connect"
		fi
	fi

	# Check if import succeded or not and print results.
	if [ $? -eq 0 ]; then
		echo-green "dsh: mysql-import finished";
		if is_tty; then _notify "Dsh" "Mysql import finished"; fi
	else
		echo-red "dsh: mysql-import failed";
		if is_tty; then _notify "Dsh" "Mysql import failed!"; fi
	fi
}

# Shortcut to run drush cc ... on site
# @param $1 type of cache to clean (all, css-js, ...)
clear_cache ()
{
	check_dsh_environment
	local type='all'
	if [[ ! "$1" == "" ]]; then
		type=$1
	fi

	_run "drush cc $type"
}

# Run Behat tests (also install dependencies through Composer)
# @param $* arguments and params passed to Behat
behat ()
{
	check_dsh_environment
	cd $(get_yml_path)

	local params=''
	local path='tests/behat'
	for i in "$@"; do
		case $i in
			--path=*)
				path="${i#*=}"
				;;
			*)
				params="$params$i "
				;;
		esac;
	done

	local project_root_path=$(get_yml_path)
	local behat_yml_path="${project_root_path}/${path}/behat.yml"
	if [[ ! -f "${behat_yml_path}" ]]; then
		echo-red "Could not find ${behat_yml_path}"
		exit 1
	fi
	_run "cd $path && composer install --prefer-source --no-interaction"
	_run "cd $path && bin/behat -p docker $params"
}

# Download script by URL and execute it
# @param $1 url of script.
exec_url ()
{
	if [[ "$1" != "" ]]; then
		local script
		script=$(curl -kfsSL "$1")
		if_failed "Failed downloading script $1"
		bash <(echo "$script")
	else
		echo-red "URL is required"
	fi
}

# Remove container(s)
# @param $1 $2... container names
remove ()
{
	check_dsh_environment
	if [[ $1 == "" ]]; then
		echo -e  "${red}WARNING:${NC} ${yellow}You have chosen to delete or re-create all project containers.${NC}"
		_confirm "Continue?";
	fi

	# support quiet removal
	if [[ $1 == "-f" ]]; then
		shift
	fi

	_remove_containers $*
}

# Reset container(s) (stop, remove, up)
# @param $1 $2... containers names
reset ()
{
	check_docker_running

	if [[ "$1" == "proxy" ]] ; then
		echo-green 'Resetting Drude HTTP/HTTPS reverse proxy service...'
		install_proxy_service
		return
	fi

	if [[ "$1" == "dns" ]] ; then
		echo-green 'Resetting Drude DNS service...'
		install_dns_service
		return
	fi

	if [[ "$1" == "ssh-agent" ]] ; then
		echo-green 'Resetting Drude ssh-agent service...'
		install_sshagent_service
		return
	fi

	if [[ "$1" == "system" ]] ; then
		echo-green 'Resetting Drude services...'
		echo 'vhost-proxy'
		install_proxy_service
		echo 'dns'
		install_dns_service
		echo 'ssh-agent'
		install_sshagent_service
		return
	fi

	check_yml
	# support quiet removal
	if [[ $1 == "-f" ]]; then
		shift
		remove -f "$*"
	else
		remove "$*"
	fi
	_start_containers
}

# Show logs
# @param $* container(s) name
logs ()
{
	docker_compose logs $*
}

# Set uid of the primary "docker" user in the cli container
# Useful to match the host uid with the uid in the cli container and avoid file permission issues this way.
_set_cli_uid ()
{
	if [[ $DRUDE_SET_UID == "" ]] ; then
		DRUDE_SET_UID=$(id -u)
	fi
	# Let uid to be set with the DRUDE_SET_UID env variable
	if [[ $DRUDE_SET_UID != 0 ]] ; then
		local host_uid=$DRUDE_SET_UID
		local container_uid=$(docker exec $(get_container_id cli) id -u)

		if [[ $container_uid != $host_uid ]]; then
			echo-green "Changing user uid in cli from $container_uid to $host_uid..."
			docker exec -u root $(get_container_id cli) usermod -u $host_uid docker
			echo-green "Reseting permissions on /var/www..."
			docker exec -u root $(get_container_id cli) chown -R docker:users /var/www
			echo-green "Restarting php daemon..."
			# TODO: Remove. This code is to support legacy cli image version, where php5-fpm service name was used.
			local php_service='php-fpm';
			local local res=$(docker exec $(get_container_id cli) grep "program:php5-fpm" /etc/supervisor/conf.d/supervisord.conf)
			if [[ "$res" != '' ]]; then php_service='php5-fpm'; fi
            docker exec -u root $(get_container_id cli) supervisorctl restart $php_service
		else
			echo-green "Container and host uids already match ($container_uid)."
		fi
	else
		echo-yellow "Running Drude as root is not recommended. Please run as a regular user with docker access."
	fi
}

_system_information_heading ()
{
	local dashes_length=$((32+${#1}))
	echo
	printf '–%.0s' $(seq 1 $dashes_length)
	echo
	echo "		$1"
	printf '–%.0s' $(seq 1 $dashes_length)
	echo
}

system_information ()
{
	_system_information_heading "OS"
	uname -a
	if is_linux; then
		[ -f /etc/os-release ] && cat /etc/os-release
		[ -f /etc/system-release ] && cat /etc/system-release
	fi
	echo -n "Current dir: "
	pwd

	_system_information_heading "Dsh"
	version

	_system_information_heading "Docker"
	echo "DOCKER_HOST:	$DOCKER_HOST"
	echo
	docker version

	_system_information_heading "Docker Compose"
	docker-compose version

	if ! is_linux; then
		_system_information_heading "VirtualBox"
		VBoxManage --version

		_system_information_heading "Running Virtual Boxes"
		VBoxManage list runningvms

		_system_information_heading "VirtualBox Network interfaces"
		VBoxManage list hostonlyifs

		_system_information_heading "Vagrant"
		vagrant --version

		_system_information_heading "Vagrant Box version"
		local vagrant_path=$(upfind Vagrantfile)
		if [[ $vagrant_path == "" ]]; then
			echo "Vagrantfile not found"
		else
			cat $vagrant_path/Vagrantfile | grep box_version
		fi

		if [[ $vagrant_path != "" ]]; then
			_system_information_heading "Vagrant Boxes List"
			vagrant global-status
		fi
	fi

	echo
}

if [[ "$*" != "update dsh" ]]; then
	check_for_updates
fi
# Command bindings
argv="$@"
case $1 in
	up)
		up
		;;
	start)
		up
		;;
	stop)
		shift
		down $*
		;;
	down)
		shift
		down $*
		;;
	halt)
		halt
		;;
	restart)
		shift
		restart $*
		;;
	reload)
		reload
		;;
	status)
		shift
		status $*
		;;
	st)
		shift
		status $*
		;;
	ps)
		shift
		status $*
		;;
	vmstat)
		vmstat
		;;
	ssh-add)
		shift
		ssh_add "$*"
		;;
	install)
		shift
		install $*
		;;
	update)
		shift
		if [[ "$1" == "prerequisites" ]]; then
			install_prerequisites
		elif [[ "$1" == "boot2docker" ]]; then
			update_boot2docker $*
		elif [[ "$1" == "images" ]]; then
			update_images
		elif [[ "$1" == "dsh" ]]; then
			update_dsh
		else
			echo "Use dsh update [prerequisites|boot2docker|images|dsh]"
		fi
		;;
	self-update)
		update_dsh
		;;
	bash)
		shift
		_bash $*
		;;
	exec)
		shift
		_run "$@"
		;;
	run)
		shift
		_run "$@"
		;;
	mysql)
		mysql
		;;
	sqlc)
		mysql
		;;
	mysql-import)
		mysql_import $2 $3
		;;
	sqli)
		mysql_import $2 $3
		;;
	cc)
		clear_cache $2
		;;
	drush)
		shift
		if [[ $1 == "" ]]; then
			_run drush
		else
			_run drush "$@"
		fi
		;;
	drupal)
		shift
		if [[ "$1" == "" ]]; then
			_run drupal
		else
			_run drupal "$@"
		fi
		;;
	behat)
		shift
		behat "$@"
		;;
	exec-url)
		shift
		exec_url "$*"
		;;
	reset)
		shift
		reset $*
		;;
	remove)
		shift
		remove $*
		;;
	cleanup)
		shift
		_docker_cleanup $1
		;;
	-v | v)
		version --short
		;;
	version)
		version
		;;
	bash_comp_words)
		shift
		bash_comp_words "$*"
		;;
	logs)
		shift
		logs $@
		;;
	"")
		show_help
		;;
	help)
		show_help $2
		;;
	system-info | sysinfo)
		system_information
		;;
	init|*)
		# Search for custom commands in $DRUDE_COMMANDS_PATH

		legacy_init_path="$(get_drude_path)/.drude/scripts/drude-init.sh"
		if [[ "$1" == "init" ]] && [[ -f $legacy_init_path ]]; then
			# Legacy processing for init script
			dsh_command_script=$legacy_init_path
		else
			# Normal search for custom command
			dsh_command_script="$(get_drude_path)/$DRUDE_COMMANDS_PATH/$1"
		fi

		if [ -f "$dsh_command_script" ]; then
			if [[ ! -x "$dsh_command_script" ]]; then
				echo -e "${yellow}$dsh_command_script${NC} is not set to be executable."
				_confirm "Fix automatically?"
				chmod +x "$dsh_command_script"
				if_failed "Could not make $dsh_command_script executable"
			fi
			shift
			export YML_PATH="$(get_yml_path)"
			export DRUDE_PATH="$(get_drude_path)"
			export PROJECT_ROOT="$(get_drude_path)"
			if is_docker_running; then
				export DOCKER_RUNNING="true"
			else
				export DOCKER_RUNNING="false"
			fi

			exec "$dsh_command_script" "$@"
		else
			echo-yellow "dsh: unknown command '"$*"'. See 'dsh help' for list of available commands"
			exit 1
		fi
esac
